{
  "version": 3,
  "sources": ["../../@noble/curves/src/abstract/bls.ts", "../../@noble/curves/src/abstract/tower.ts", "../../@noble/curves/src/bls12-381.ts", "../../@mysten/seal/src/bcs.ts", "../../@mysten/seal/src/error.ts", "../../@mysten/seal/src/bls12381.ts", "../../@noble/hashes/src/hkdf.ts", "../../@noble/hashes/src/sha3.ts", "../../@mysten/seal/src/kdf.ts", "../../@mysten/seal/src/utils.ts", "../../@mysten/seal/src/ibe.ts", "../../@mysten/seal/src/version.ts", "../../@mysten/seal/src/key-server.ts", "../../shamir-secret-sharing/src/csprng.ts", "../../shamir-secret-sharing/src/index.ts", "../../@mysten/seal/src/dem.ts", "../../@mysten/seal/src/decrypt.ts", "../../@mysten/seal/src/encrypt.ts", "../../@mysten/seal/src/elgamal.ts", "../../@mysten/seal/src/keys.ts", "../../@mysten/seal/src/client.ts", "../../@noble/curves/src/secp256k1.ts", "../../@mysten/sui/src/keypairs/secp256k1/publickey.ts", "../../@mysten/sui/src/keypairs/secp256r1/publickey.ts", "../../@mysten/sui/src/multisig/signer.ts", "../../@mysten/sui/src/multisig/publickey.ts", "../../@mysten/sui/src/verify/verify.ts", "../../@mysten/seal/src/session-key.ts"],
  "sourcesContent": ["/**\r\n * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\r\n * BLS != BLS.\r\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\r\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\r\n * families of pairing-friendly curves.\r\n * Consists of two curves: G1 and G2:\r\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\r\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\r\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\r\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\r\n * Pairing is used to aggregate and verify signatures.\r\n * There are two main ways to use it:\r\n * 1. Fp for short private keys, Fp₂ for signatures\r\n * 2. Fp for short signatures, Fp₂ for private keys\r\n * @module\r\n **/\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// TODO: import { AffinePoint } from './curve.js';\r\nimport { type IField, getMinHashLength, mapHashToField } from './modular.js';\r\nimport { type CHash, type Hex, type PrivKey, ensureBytes, memoized } from './utils.js';\r\n// prettier-ignore\r\nimport {\r\n  type H2CPointConstructor, type htfBasicOpts,\r\n  type Opts as HTFOpts,\r\n  type MapToCurve,\r\n  createHasher\r\n} from './hash-to-curve.js';\r\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6 } from './tower.js';\r\nimport {\r\n  type CurvePointsRes,\r\n  type CurvePointsType,\r\n  type ProjPointType,\r\n  weierstrassPoints,\r\n} from './weierstrass.js';\r\n\r\ntype Fp = bigint; // Can be different field?\r\n\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\r\n\r\nexport type TwistType = 'multiplicative' | 'divisive';\r\n\r\nexport type ShortSignatureCoder<Fp> = {\r\n  fromHex(hex: Hex): ProjPointType<Fp>;\r\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\r\n  toHex(point: ProjPointType<Fp>): string;\r\n};\r\n\r\nexport type SignatureCoder<Fp> = {\r\n  fromHex(hex: Hex): ProjPointType<Fp>;\r\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\r\n  toHex(point: ProjPointType<Fp>): string;\r\n};\r\n\r\nexport type PostPrecomputePointAddFn = (\r\n  Rx: Fp2,\r\n  Ry: Fp2,\r\n  Rz: Fp2,\r\n  Qx: Fp2,\r\n  Qy: Fp2\r\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\r\nexport type PostPrecomputeFn = (\r\n  Rx: Fp2,\r\n  Ry: Fp2,\r\n  Rz: Fp2,\r\n  Qx: Fp2,\r\n  Qy: Fp2,\r\n  pointAdd: PostPrecomputePointAddFn\r\n) => void;\r\nexport type CurveType = {\r\n  G1: Omit<CurvePointsType<Fp>, 'n'> & {\r\n    ShortSignature: SignatureCoder<Fp>;\r\n    mapToCurve: MapToCurve<Fp>;\r\n    htfDefaults: HTFOpts;\r\n  };\r\n  G2: Omit<CurvePointsType<Fp2>, 'n'> & {\r\n    Signature: SignatureCoder<Fp2>;\r\n    mapToCurve: MapToCurve<Fp2>;\r\n    htfDefaults: HTFOpts;\r\n  };\r\n  fields: {\r\n    Fp: IField<Fp>;\r\n    Fr: IField<bigint>;\r\n    Fp2: Fp2Bls;\r\n    Fp6: IField<Fp6>;\r\n    Fp12: Fp12Bls;\r\n  };\r\n  params: {\r\n    // NOTE: MSB is always ignored and used as marker for length,\r\n    // otherwise leading zeros will be lost.\r\n    // Can be different from 'X' (seed) param!\r\n    ateLoopSize: bigint;\r\n    xNegative: boolean;\r\n    r: bigint;\r\n    twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\r\n  };\r\n  htfDefaults: HTFOpts;\r\n  hash: CHash; // Because we need outputLen for DRBG\r\n  randomBytes: (bytesLength?: number) => Uint8Array;\r\n  // This is super ugly hack for untwist point in BN254 after miller loop\r\n  postPrecompute?: PostPrecomputeFn;\r\n};\r\n\r\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\r\ntype Precompute = PrecomputeSingle[];\r\n\r\nexport type CurveFn = {\r\n  getPublicKey: (privateKey: PrivKey) => Uint8Array;\r\n  getPublicKeyForShortSignatures: (privateKey: PrivKey) => Uint8Array;\r\n  sign: {\r\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\r\n    (message: ProjPointType<Fp2>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp2>;\r\n  };\r\n  signShortSignature: {\r\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\r\n    (message: ProjPointType<Fp>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp>;\r\n  };\r\n  verify: (\r\n    signature: Hex | ProjPointType<Fp2>,\r\n    message: Hex | ProjPointType<Fp2>,\r\n    publicKey: Hex | ProjPointType<Fp>,\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  verifyShortSignature: (\r\n    signature: Hex | ProjPointType<Fp>,\r\n    message: Hex | ProjPointType<Fp>,\r\n    publicKey: Hex | ProjPointType<Fp2>,\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  verifyBatch: (\r\n    signature: Hex | ProjPointType<Fp2>,\r\n    messages: (Hex | ProjPointType<Fp2>)[],\r\n    publicKeys: (Hex | ProjPointType<Fp>)[],\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  aggregatePublicKeys: {\r\n    (publicKeys: Hex[]): Uint8Array;\r\n    (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\r\n  };\r\n  aggregateSignatures: {\r\n    (signatures: Hex[]): Uint8Array;\r\n    (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\r\n  };\r\n  aggregateShortSignatures: {\r\n    (signatures: Hex[]): Uint8Array;\r\n    (signatures: ProjPointType<Fp>[]): ProjPointType<Fp>;\r\n  };\r\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\r\n  pairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\r\n  pairingBatch: (\r\n    pairs: { g1: ProjPointType<Fp>; g2: ProjPointType<Fp2> }[],\r\n    withFinalExponent?: boolean\r\n  ) => Fp12;\r\n  G1: CurvePointsRes<Fp> & ReturnType<typeof createHasher<Fp>>;\r\n  G2: CurvePointsRes<Fp2> & ReturnType<typeof createHasher<Fp2>>;\r\n  Signature: SignatureCoder<Fp2>;\r\n  ShortSignature: ShortSignatureCoder<Fp>;\r\n  params: {\r\n    ateLoopSize: bigint;\r\n    r: bigint;\r\n    G1b: bigint;\r\n    G2b: Fp2;\r\n  };\r\n  fields: {\r\n    Fp: IField<Fp>;\r\n    Fp2: Fp2Bls;\r\n    Fp6: IField<Fp6>;\r\n    Fp12: Fp12Bls;\r\n    Fr: IField<bigint>;\r\n  };\r\n  utils: {\r\n    randomPrivateKey: () => Uint8Array;\r\n    calcPairingPrecomputes: (p: ProjPointType<Fp2>) => Precompute;\r\n  };\r\n};\r\n\r\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\r\nfunction NAfDecomposition(a: bigint) {\r\n  const res = [];\r\n  // a>1 because of marker bit\r\n  for (; a > _1n; a >>= _1n) {\r\n    if ((a & _1n) === _0n) res.unshift(0);\r\n    else if ((a & _3n) === _3n) {\r\n      res.unshift(-1);\r\n      a += _1n;\r\n    } else res.unshift(1);\r\n  }\r\n  return res;\r\n}\r\n\r\nexport function bls(CURVE: CurveType): CurveFn {\r\n  // Fields are specific for curve, so for now we'll need to pass them with opts\r\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\r\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\r\n  const TWIST: TwistType = CURVE.params.twistType;\r\n  // Point on G1 curve: (x, y)\r\n  const G1_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G1 });\r\n  const G1 = Object.assign(\r\n    G1_,\r\n    createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\r\n      ...CURVE.htfDefaults,\r\n      ...CURVE.G1.htfDefaults,\r\n    })\r\n  );\r\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\r\n  const G2_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G2 });\r\n  const G2 = Object.assign(\r\n    G2_,\r\n    createHasher(G2_.ProjectivePoint as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\r\n      ...CURVE.htfDefaults,\r\n      ...CURVE.G2.htfDefaults,\r\n    })\r\n  );\r\n  type G1 = typeof G1.ProjectivePoint.BASE;\r\n  type G2 = typeof G2.ProjectivePoint.BASE;\r\n\r\n  // Applies sparse multiplication as line function\r\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\r\n  if (TWIST === 'multiplicative') {\r\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\r\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\r\n  } else if (TWIST === 'divisive') {\r\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\r\n    // precompute calculations.\r\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\r\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\r\n  } else throw new Error('bls: unknown twist type');\r\n\r\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\r\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\r\n    const t0 = Fp2.sqr(Ry); // Ry²\r\n    const t1 = Fp2.sqr(Rz); // Rz²\r\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\r\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\r\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\r\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\r\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\r\n    const c2 = Fp2.neg(t4); // -T4 (-h)\r\n\r\n    ell.push([c0, c1, c2]);\r\n\r\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\r\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\r\n    Rz = Fp2.mul(t0, t4); // T0 * T4\r\n    return { Rx, Ry, Rz };\r\n  }\r\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\r\n    // Addition\r\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\r\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\r\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\r\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\r\n    const c2 = t1; // == Rx - Qx * Rz\r\n\r\n    ell.push([c0, c1, c2]);\r\n\r\n    const t2 = Fp2.sqr(t1); // T1²\r\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\r\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\r\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\r\n    Rx = Fp2.mul(t1, t5); // T1 * T5\r\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\r\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\r\n    return { Rx, Ry, Rz };\r\n  }\r\n\r\n  // Pre-compute coefficients for sparse multiplication\r\n  // Point addition and point double calculations is reused for coefficients\r\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\r\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\r\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\r\n\r\n  const calcPairingPrecomputes = memoized((point: G2) => {\r\n    const p = point;\r\n    const { x, y } = p.toAffine();\r\n    // prettier-ignore\r\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\r\n    // prettier-ignore\r\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\r\n    const ell: Precompute = [];\r\n    for (const bit of ATE_NAF) {\r\n      const cur: PrecomputeSingle = [];\r\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\r\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\r\n      ell.push(cur);\r\n    }\r\n    if (CURVE.postPrecompute) {\r\n      const last = ell[ell.length - 1];\r\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\r\n    }\r\n    return ell;\r\n  });\r\n\r\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\r\n  // Applies calculated precomputes\r\n  type MillerInput = [Precompute, Fp, Fp][];\r\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\r\n    let f12 = Fp12.ONE;\r\n    if (pairs.length) {\r\n      const ellLen = pairs[0][0].length;\r\n      for (let i = 0; i < ellLen; i++) {\r\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\r\n        // NOTE: we apply multiple pairings in parallel here\r\n        for (const [ell, Px, Py] of pairs) {\r\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\r\n        }\r\n      }\r\n    }\r\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\r\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\r\n  }\r\n  type PairingInput = { g1: G1; g2: G2 };\r\n  // Calculates product of multiple pairings\r\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\r\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\r\n    const res: MillerInput = [];\r\n    // This cache precomputed toAffine for all points\r\n    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\r\n    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\r\n    for (const { g1, g2 } of pairs) {\r\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\r\n        throw new Error('pairing is not available for ZERO point');\r\n      // This uses toAffine inside\r\n      g1.assertValidity();\r\n      g2.assertValidity();\r\n      const Qa = g1.toAffine();\r\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\r\n    }\r\n    return millerLoopBatch(res, withFinalExponent);\r\n  }\r\n  // Calculates bilinear pairing\r\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\r\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\r\n  }\r\n\r\n  const utils = {\r\n    randomPrivateKey: (): Uint8Array => {\r\n      const length = getMinHashLength(Fr.ORDER);\r\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\r\n    },\r\n    calcPairingPrecomputes,\r\n  };\r\n\r\n  const { ShortSignature } = CURVE.G1;\r\n  const { Signature } = CURVE.G2;\r\n\r\n  type G1Hex = Hex | G1;\r\n  type G2Hex = Hex | G2;\r\n  function normP1(point: G1Hex): G1 {\r\n    return point instanceof G1.ProjectivePoint ? (point as G1) : G1.ProjectivePoint.fromHex(point);\r\n  }\r\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\r\n    return point instanceof G1.ProjectivePoint\r\n      ? point\r\n      : (G1.hashToCurve(ensureBytes('point', point), htfOpts) as G1);\r\n  }\r\n  function normP2(point: G2Hex): G2 {\r\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\r\n  }\r\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\r\n    return point instanceof G2.ProjectivePoint\r\n      ? point\r\n      : (G2.hashToCurve(ensureBytes('point', point), htfOpts) as G2);\r\n  }\r\n\r\n  // Multiplies generator (G1) by private key.\r\n  // P = pk x G\r\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\r\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\r\n  }\r\n\r\n  // Multiplies generator (G2) by private key.\r\n  // P = pk x G\r\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\r\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\r\n  }\r\n\r\n  // Executes `hashToCurve` on the message and then multiplies the result by private key.\r\n  // S = pk x H(m)\r\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\r\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\r\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\r\n    const msgPoint = normP2Hash(message, htfOpts);\r\n    msgPoint.assertValidity();\r\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\r\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\r\n    return Signature.toRawBytes(sigPoint);\r\n  }\r\n\r\n  function signShortSignature(\r\n    message: Hex,\r\n    privateKey: PrivKey,\r\n    htfOpts?: htfBasicOpts\r\n  ): Uint8Array;\r\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\r\n  function signShortSignature(\r\n    message: G1Hex,\r\n    privateKey: PrivKey,\r\n    htfOpts?: htfBasicOpts\r\n  ): Uint8Array | G1 {\r\n    const msgPoint = normP1Hash(message, htfOpts);\r\n    msgPoint.assertValidity();\r\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\r\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\r\n    return ShortSignature.toRawBytes(sigPoint);\r\n  }\r\n\r\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\r\n  // e(P, H(m)) == e(G, S)\r\n  function verify(\r\n    signature: G2Hex,\r\n    message: G2Hex,\r\n    publicKey: G1Hex,\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    const P = normP1(publicKey);\r\n    const Hm = normP2Hash(message, htfOpts);\r\n    const G = G1.ProjectivePoint.BASE;\r\n    const S = normP2(signature);\r\n    const exp = pairingBatch([\r\n      { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\r\n      { g1: G, g2: S }, // eGS = pairing(G, S, false);\r\n    ]);\r\n    return Fp12.eql(exp, Fp12.ONE);\r\n  }\r\n\r\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\r\n  // e(S, G) == e(H(m), P)\r\n  function verifyShortSignature(\r\n    signature: G1Hex,\r\n    message: G1Hex,\r\n    publicKey: G2Hex,\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    const P = normP2(publicKey);\r\n    const Hm = normP1Hash(message, htfOpts);\r\n    const G = G2.ProjectivePoint.BASE;\r\n    const S = normP1(signature);\r\n    const exp = pairingBatch([\r\n      { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\r\n      { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\r\n    ]);\r\n    return Fp12.eql(exp, Fp12.ONE);\r\n  }\r\n\r\n  function aNonEmpty(arr: any[]) {\r\n    if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\r\n  }\r\n\r\n  // Adds a bunch of public key points together.\r\n  // pk1 + pk2 + pk3 = pkA\r\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\r\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\r\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\r\n    aNonEmpty(publicKeys);\r\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    // toRawBytes ensures point validity\r\n    return aggAffine.toRawBytes(true);\r\n  }\r\n\r\n  // Adds a bunch of signature points together.\r\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\r\n  function aggregateSignatures(signatures: G2[]): G2;\r\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\r\n    aNonEmpty(signatures);\r\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (signatures[0] instanceof G2.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    return Signature.toRawBytes(aggAffine);\r\n  }\r\n\r\n  // Adds a bunch of signature points together.\r\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\r\n  function aggregateShortSignatures(signatures: G1[]): G1;\r\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\r\n    aNonEmpty(signatures);\r\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (signatures[0] instanceof G1.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    return ShortSignature.toRawBytes(aggAffine);\r\n  }\r\n\r\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\r\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\r\n  function verifyBatch(\r\n    signature: G2Hex,\r\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\r\n    messages: G2Hex[],\r\n    publicKeys: G1Hex[],\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    aNonEmpty(messages);\r\n    if (publicKeys.length !== messages.length)\r\n      throw new Error('amount of public keys and messages should be equal');\r\n    const sig = normP2(signature);\r\n    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\r\n    const nPublicKeys = publicKeys.map(normP1);\r\n    // NOTE: this works only for exact same object\r\n    const messagePubKeyMap = new Map<G2, G1[]>();\r\n    for (let i = 0; i < nPublicKeys.length; i++) {\r\n      const pub = nPublicKeys[i];\r\n      const msg = nMessages[i];\r\n      let keys = messagePubKeyMap.get(msg);\r\n      if (keys === undefined) {\r\n        keys = [];\r\n        messagePubKeyMap.set(msg, keys);\r\n      }\r\n      keys.push(pub);\r\n    }\r\n    const paired = [];\r\n    try {\r\n      for (const [msg, keys] of messagePubKeyMap) {\r\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\r\n        paired.push({ g1: groupPublicKey, g2: msg });\r\n      }\r\n      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\r\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  G1.ProjectivePoint.BASE._setWindowSize(4);\r\n\r\n  return {\r\n    getPublicKey,\r\n    getPublicKeyForShortSignatures,\r\n    sign,\r\n    signShortSignature,\r\n    verify,\r\n    verifyBatch,\r\n    verifyShortSignature,\r\n    aggregatePublicKeys,\r\n    aggregateSignatures,\r\n    aggregateShortSignatures,\r\n    millerLoopBatch,\r\n    pairing,\r\n    pairingBatch,\r\n    G1,\r\n    G2,\r\n    Signature,\r\n    ShortSignature,\r\n    fields: {\r\n      Fr,\r\n      Fp,\r\n      Fp2,\r\n      Fp6,\r\n      Fp12,\r\n    },\r\n    params: {\r\n      ateLoopSize: CURVE.params.ateLoopSize,\r\n      r: CURVE.params.r,\r\n      G1b: CURVE.G1.b,\r\n      G2b: CURVE.G2.b,\r\n    },\r\n    utils,\r\n  };\r\n}\r\n", "/**\r\n * Towered extension fields.\r\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\r\n * to build it up from smaller extensions: a tower of extensions.\r\n *\r\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\r\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\r\n *\r\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport * as mod from './modular.js';\r\nimport { bitLen, bitMask, concatBytes, notImplemented } from './utils.js';\r\nimport type { ProjConstructor, ProjPointType } from './weierstrass.js';\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\r\n\r\n// Fp₂ over complex plane\r\nexport type BigintTuple = [bigint, bigint];\r\nexport type Fp = bigint;\r\n// Finite extension field over irreducible polynominal.\r\n// Fp(u) / (u² - β) where β = -1\r\nexport type Fp2 = { c0: bigint; c1: bigint };\r\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\r\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\r\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\r\n// prettier-ignore\r\nexport type BigintTwelve = [\r\n  bigint, bigint, bigint, bigint, bigint, bigint,\r\n  bigint, bigint, bigint, bigint, bigint, bigint\r\n];\r\n\r\nexport type Fp2Bls = mod.IField<Fp2> & {\r\n  reim: (num: Fp2) => { re: Fp; im: Fp };\r\n  mulByB: (num: Fp2) => Fp2;\r\n  frobeniusMap(num: Fp2, power: number): Fp2;\r\n  fromBigTuple(num: [bigint, bigint]): Fp2;\r\n};\r\n\r\nexport type Fp12Bls = mod.IField<Fp12> & {\r\n  frobeniusMap(num: Fp12, power: number): Fp12;\r\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\r\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\r\n  conjugate(num: Fp12): Fp12;\r\n  finalExponentiate(num: Fp12): Fp12;\r\n  fromBigTwelve(num: BigintTwelve): Fp12;\r\n};\r\n\r\nfunction calcFrobeniusCoefficients<T>(\r\n  Fp: mod.IField<T>,\r\n  nonResidue: T,\r\n  modulus: bigint,\r\n  degree: number,\r\n  num: number = 1,\r\n  divisor?: number\r\n) {\r\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\r\n  const towerModulus: any = modulus ** BigInt(degree);\r\n  const res: T[][] = [];\r\n  for (let i = 0; i < num; i++) {\r\n    const a = BigInt(i + 1);\r\n    const powers: T[] = [];\r\n    for (let j = 0, qPower = _1n; j < degree; j++) {\r\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\r\n      powers.push(Fp.pow(nonResidue, power));\r\n      qPower *= modulus;\r\n    }\r\n    res.push(powers);\r\n  }\r\n  return res;\r\n}\r\n\r\n// This works same at least for bls12-381, bn254 and bls12-377\r\nexport function psiFrobenius(\r\n  Fp: mod.IField<Fp>,\r\n  Fp2: Fp2Bls,\r\n  base: Fp2\r\n): {\r\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\r\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\r\n  G2psi: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\r\n  G2psi2: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\r\n  PSI_X: Fp2;\r\n  PSI_Y: Fp2;\r\n  PSI2_X: Fp2;\r\n  PSI2_Y: Fp2;\r\n} {\r\n  // Ψ endomorphism\r\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\r\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\r\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\r\n    // This x10 faster than previous version in bls12-381\r\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\r\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\r\n    return [x2, y2];\r\n  }\r\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\r\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\r\n  // This equals -1, which causes y to be Fp2.neg(y).\r\n  // But not sure if there are case when this is not true?\r\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\r\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\r\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\r\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\r\n  }\r\n  // Map points\r\n  const mapAffine =\r\n    <T>(fn: (x: T, y: T) => [T, T]) =>\r\n    (c: ProjConstructor<T>, P: ProjPointType<T>) => {\r\n      const affine = P.toAffine();\r\n      const p = fn(affine.x, affine.y);\r\n      return c.fromAffine({ x: p[0], y: p[1] });\r\n    };\r\n  const G2psi = mapAffine(psi);\r\n  const G2psi2 = mapAffine(psi2);\r\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\r\n}\r\n\r\nexport type Tower12Opts = {\r\n  ORDER: bigint;\r\n  NONRESIDUE?: Fp;\r\n  // Fp2\r\n  FP2_NONRESIDUE: BigintTuple;\r\n  Fp2sqrt?: (num: Fp2) => Fp2;\r\n  Fp2mulByB: (num: Fp2) => Fp2;\r\n  // Fp12\r\n  Fp12cyclotomicSquare: (num: Fp12) => Fp12;\r\n  Fp12cyclotomicExp: (num: Fp12, n: bigint) => Fp12;\r\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\r\n};\r\n\r\nexport function tower12(opts: Tower12Opts): {\r\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\r\n  Fp2: mod.IField<Fp2> & {\r\n    NONRESIDUE: Fp2;\r\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\r\n    reim: (num: Fp2) => { re: bigint; im: bigint };\r\n    mulByNonresidue: (num: Fp2) => Fp2;\r\n    mulByB: (num: Fp2) => Fp2;\r\n    frobeniusMap(num: Fp2, power: number): Fp2;\r\n  };\r\n  Fp6: mod.IField<Fp6> & {\r\n    fromBigSix: (tuple: BigintSix) => Fp6;\r\n    mulByNonresidue: (num: Fp6) => Fp6;\r\n    frobeniusMap(num: Fp6, power: number): Fp6;\r\n    mul1(num: Fp6, b1: Fp2): Fp6;\r\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\r\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\r\n  };\r\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\r\n  Fp12: mod.IField<Fp12> & {\r\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\r\n    frobeniusMap(num: Fp12, power: number): Fp12;\r\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\r\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\r\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\r\n    conjugate(num: Fp12): Fp12;\r\n    finalExponentiate(num: Fp12): Fp12;\r\n    _cyclotomicSquare(num: Fp12): Fp12;\r\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\r\n  };\r\n} {\r\n  const { ORDER } = opts;\r\n  // Fp\r\n  const Fp = mod.Field(ORDER);\r\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\r\n  const FpLegendre = mod.FpLegendre(ORDER);\r\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\r\n\r\n  // Fp2\r\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\r\n  const Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\r\n    c0: Fp.add(c0, r0),\r\n    c1: Fp.add(c1, r1),\r\n  });\r\n  const Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\r\n    c0: Fp.sub(c0, r0),\r\n    c1: Fp.sub(c1, r1),\r\n  });\r\n  const Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\r\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\r\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\r\n    const { c0: r0, c1: r1 } = rhs;\r\n    let t1 = Fp.mul(c0, r0); // c0 * o0\r\n    let t2 = Fp.mul(c1, r1); // c1 * o1\r\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\r\n    const o0 = Fp.sub(t1, t2);\r\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\r\n    return { c0: o0, c1: o1 };\r\n  };\r\n  const Fp2Square = ({ c0, c1 }: Fp2) => {\r\n    const a = Fp.add(c0, c1);\r\n    const b = Fp.sub(c0, c1);\r\n    const c = Fp.add(c0, c0);\r\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\r\n  };\r\n  type Fp2Utils = {\r\n    NONRESIDUE: Fp2;\r\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\r\n    reim: (num: Fp2) => { re: bigint; im: bigint };\r\n    mulByNonresidue: (num: Fp2) => Fp2;\r\n    mulByB: (num: Fp2) => Fp2;\r\n    frobeniusMap(num: Fp2, power: number): Fp2;\r\n  };\r\n  const Fp2fromBigTuple = (tuple: BigintTuple | bigint[]) => {\r\n    if (tuple.length !== 2) throw new Error('invalid tuple');\r\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\r\n    return { c0: fps[0], c1: fps[1] };\r\n  };\r\n\r\n  const FP2_ORDER = ORDER * ORDER;\r\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\r\n  const Fp2: mod.IField<Fp2> & Fp2Utils = {\r\n    ORDER: FP2_ORDER,\r\n    isLE: Fp.isLE,\r\n    NONRESIDUE: Fp2Nonresidue,\r\n    BITS: bitLen(FP2_ORDER),\r\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\r\n    MASK: bitMask(bitLen(FP2_ORDER)),\r\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\r\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\r\n    create: (num) => num,\r\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\r\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\r\n    eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\r\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\r\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\r\n    invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\r\n    // Normalized\r\n    add: Fp2Add,\r\n    sub: Fp2Subtract,\r\n    mul: Fp2Multiply,\r\n    sqr: Fp2Square,\r\n    // NonNormalized stuff\r\n    addN: Fp2Add,\r\n    subN: Fp2Subtract,\r\n    mulN: Fp2Multiply,\r\n    sqrN: Fp2Square,\r\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\r\n    div: (lhs, rhs) =>\r\n      Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\r\n    inv: ({ c0: a, c1: b }) => {\r\n      // We wish to find the multiplicative inverse of a nonzero\r\n      // element a + bu in Fp2. We leverage an identity\r\n      //\r\n      // (a + bu)(a - bu) = a² + b²\r\n      //\r\n      // which holds because u² = -1. This can be rewritten as\r\n      //\r\n      // (a + bu)(a - bu)/(a² + b²) = 1\r\n      //\r\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\r\n      // This gives that (a - bu)/(a² + b²) is the inverse\r\n      // of (a + bu). Importantly, this can be computing using\r\n      // only a single inversion in Fp.\r\n      const factor = Fp.inv(Fp.create(a * a + b * b));\r\n      return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\r\n    },\r\n    sqrt: (num) => {\r\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\r\n      // This is generic for all quadratic extensions (Fp2)\r\n      const { c0, c1 } = num;\r\n      if (Fp.is0(c1)) {\r\n        // if c0 is quadratic residue\r\n        if (Fp.eql(FpLegendre(Fp, c0), Fp.ONE)) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\r\n        else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\r\n      }\r\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\r\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\r\n      const legendre = FpLegendre(Fp, d);\r\n      // -1, Quadratic non residue\r\n      if (!Fp.is0(legendre) && !Fp.eql(legendre, Fp.ONE)) d = Fp.sub(d, a);\r\n      const a0 = Fp.sqrt(d);\r\n      const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\r\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\r\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\r\n      const x1 = candidateSqrt;\r\n      const x2 = Fp2.neg(x1);\r\n      const { re: re1, im: im1 } = Fp2.reim(x1);\r\n      const { re: re2, im: im2 } = Fp2.reim(x2);\r\n      if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\r\n      return x2;\r\n    },\r\n    // Same as sgn0_m_eq_2 in RFC 9380\r\n    isOdd: (x: Fp2) => {\r\n      const { re: x0, im: x1 } = Fp2.reim(x);\r\n      const sign_0 = x0 % _2n;\r\n      const zero_0 = x0 === _0n;\r\n      const sign_1 = x1 % _2n;\r\n      return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\r\n    },\r\n    // Bytes util\r\n    fromBytes(b: Uint8Array): Fp2 {\r\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\r\n      return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\r\n    },\r\n    toBytes: ({ c0, c1 }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\r\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\r\n      c0: Fp.cmov(c0, r0, c),\r\n      c1: Fp.cmov(c1, r1, c),\r\n    }),\r\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\r\n    // multiply by u + 1\r\n    mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\r\n    mulByB: opts.Fp2mulByB,\r\n    fromBigTuple: Fp2fromBigTuple,\r\n    frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\r\n      c0,\r\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\r\n    }),\r\n  };\r\n  // Fp6\r\n  const Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\r\n    c0: Fp2.add(c0, r0),\r\n    c1: Fp2.add(c1, r1),\r\n    c2: Fp2.add(c2, r2),\r\n  });\r\n  const Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\r\n    c0: Fp2.sub(c0, r0),\r\n    c1: Fp2.sub(c1, r1),\r\n    c2: Fp2.sub(c2, r2),\r\n  });\r\n  const Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\r\n    if (typeof rhs === 'bigint') {\r\n      return {\r\n        c0: Fp2.mul(c0, rhs),\r\n        c1: Fp2.mul(c1, rhs),\r\n        c2: Fp2.mul(c2, rhs),\r\n      };\r\n    }\r\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\r\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\r\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\r\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\r\n    return {\r\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\r\n      c0: Fp2.add(\r\n        t0,\r\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\r\n      ),\r\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\r\n      c1: Fp2.add(\r\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\r\n        Fp2.mulByNonresidue(t2)\r\n      ),\r\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\r\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\r\n    };\r\n  };\r\n  const Fp6Square = ({ c0, c1, c2 }: Fp6) => {\r\n    let t0 = Fp2.sqr(c0); // c0²\r\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\r\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\r\n    let t4 = Fp2.sqr(c2); // c2²\r\n    return {\r\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\r\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\r\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\r\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\r\n    };\r\n  };\r\n  type Fp6Utils = {\r\n    fromBigSix: (tuple: BigintSix) => Fp6;\r\n    mulByNonresidue: (num: Fp6) => Fp6;\r\n    frobeniusMap(num: Fp6, power: number): Fp6;\r\n    mul1(num: Fp6, b1: Fp2): Fp6;\r\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\r\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\r\n  };\r\n\r\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(\r\n    Fp2,\r\n    Fp2Nonresidue,\r\n    Fp.ORDER,\r\n    6,\r\n    2,\r\n    3\r\n  );\r\n\r\n  const Fp6: mod.IField<Fp6> & Fp6Utils = {\r\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\r\n    isLE: Fp2.isLE,\r\n    BITS: 3 * Fp2.BITS,\r\n    BYTES: 3 * Fp2.BYTES,\r\n    MASK: bitMask(3 * Fp2.BITS),\r\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\r\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\r\n    create: (num) => num,\r\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\r\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\r\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\r\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\r\n      Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\r\n    sqrt: notImplemented,\r\n    // Do we need division by bigint at all? Should be done via order:\r\n    div: (lhs, rhs) =>\r\n      Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\r\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\r\n    invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\r\n    // Normalized\r\n    add: Fp6Add,\r\n    sub: Fp6Subtract,\r\n    mul: Fp6Multiply,\r\n    sqr: Fp6Square,\r\n    // NonNormalized stuff\r\n    addN: Fp6Add,\r\n    subN: Fp6Subtract,\r\n    mulN: Fp6Multiply,\r\n    sqrN: Fp6Square,\r\n\r\n    inv: ({ c0, c1, c2 }) => {\r\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\r\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\r\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\r\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\r\n      let t4 = Fp2.inv(\r\n        Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\r\n      );\r\n      return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\r\n    },\r\n    // Bytes utils\r\n    fromBytes: (b: Uint8Array): Fp6 => {\r\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\r\n      return {\r\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\r\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\r\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\r\n      };\r\n    },\r\n    toBytes: ({ c0, c1, c2 }): Uint8Array =>\r\n      concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\r\n    cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\r\n      c0: Fp2.cmov(c0, r0, c),\r\n      c1: Fp2.cmov(c1, r1, c),\r\n      c2: Fp2.cmov(c2, r2, c),\r\n    }),\r\n    fromBigSix: (t: BigintSix): Fp6 => {\r\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\r\n      return {\r\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\r\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\r\n        c2: Fp2.fromBigTuple(t.slice(4, 6)),\r\n      };\r\n    },\r\n    frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\r\n      c0: Fp2.frobeniusMap(c0, power),\r\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\r\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\r\n    }),\r\n    mulByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\r\n      c0: Fp2.mul(c0, rhs),\r\n      c1: Fp2.mul(c1, rhs),\r\n      c2: Fp2.mul(c2, rhs),\r\n    }),\r\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\r\n    // Sparse multiplication\r\n    mul1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\r\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\r\n      c1: Fp2.mul(c0, b1),\r\n      c2: Fp2.mul(c1, b1),\r\n    }),\r\n    // Sparse multiplication\r\n    mul01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\r\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\r\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\r\n      return {\r\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\r\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\r\n        // (b0 + b1) * (c0 + c1) - T0 - T1\r\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\r\n        // (c0 + c2) * b0 - T0 + T1\r\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\r\n      };\r\n    },\r\n  };\r\n\r\n  // Fp12\r\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\r\n    Fp2,\r\n    Fp2Nonresidue,\r\n    Fp.ORDER,\r\n    12,\r\n    1,\r\n    6\r\n  )[0];\r\n\r\n  const Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\r\n    c0: Fp6.add(c0, r0),\r\n    c1: Fp6.add(c1, r1),\r\n  });\r\n  const Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\r\n    c0: Fp6.sub(c0, r0),\r\n    c1: Fp6.sub(c1, r1),\r\n  });\r\n  const Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\r\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\r\n    let { c0: r0, c1: r1 } = rhs;\r\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\r\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\r\n    return {\r\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\r\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\r\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\r\n    };\r\n  };\r\n  const Fp12Square = ({ c0, c1 }: Fp12) => {\r\n    let ab = Fp6.mul(c0, c1); // c0 * c1\r\n    return {\r\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\r\n      c0: Fp6.sub(\r\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\r\n        Fp6.mulByNonresidue(ab)\r\n      ),\r\n      c1: Fp6.add(ab, ab),\r\n    }; // AB + AB\r\n  };\r\n  function Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\r\n    const a2 = Fp2.sqr(a);\r\n    const b2 = Fp2.sqr(b);\r\n    return {\r\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\r\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\r\n    };\r\n  }\r\n  type Fp12Utils = {\r\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\r\n    frobeniusMap(num: Fp12, power: number): Fp12;\r\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\r\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\r\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\r\n    conjugate(num: Fp12): Fp12;\r\n    finalExponentiate(num: Fp12): Fp12;\r\n    _cyclotomicSquare(num: Fp12): Fp12;\r\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\r\n  };\r\n\r\n  const Fp12: mod.IField<Fp12> & Fp12Utils = {\r\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\r\n    isLE: Fp6.isLE,\r\n    BITS: 2 * Fp2.BITS,\r\n    BYTES: 2 * Fp2.BYTES,\r\n    MASK: bitMask(2 * Fp2.BITS),\r\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\r\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\r\n    create: (num) => num,\r\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\r\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\r\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\r\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\r\n    sqrt: notImplemented,\r\n    inv: ({ c0, c1 }) => {\r\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\r\n      return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\r\n    },\r\n    div: (lhs, rhs) =>\r\n      Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\r\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\r\n    invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\r\n    // Normalized\r\n    add: Fp12Add,\r\n    sub: Fp12Subtract,\r\n    mul: Fp12Multiply,\r\n    sqr: Fp12Square,\r\n    // NonNormalized stuff\r\n    addN: Fp12Add,\r\n    subN: Fp12Subtract,\r\n    mulN: Fp12Multiply,\r\n    sqrN: Fp12Square,\r\n\r\n    // Bytes utils\r\n    fromBytes: (b: Uint8Array): Fp12 => {\r\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\r\n      return {\r\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\r\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\r\n      };\r\n    },\r\n    toBytes: ({ c0, c1 }): Uint8Array => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\r\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\r\n      c0: Fp6.cmov(c0, r0, c),\r\n      c1: Fp6.cmov(c1, r1, c),\r\n    }),\r\n    // Utils\r\n    // toString() {\r\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\r\n    // },\r\n    // fromTuple(c: [Fp6, Fp6]) {\r\n    //   return new Fp12(...c);\r\n    // }\r\n    fromBigTwelve: (t: BigintTwelve): Fp12 => ({\r\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\r\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\r\n    }),\r\n    // Raises to q**i -th power\r\n    frobeniusMap(lhs, power: number) {\r\n      const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\r\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\r\n      return {\r\n        c0: Fp6.frobeniusMap(lhs.c0, power),\r\n        c1: Fp6.create({\r\n          c0: Fp2.mul(c0, coeff),\r\n          c1: Fp2.mul(c1, coeff),\r\n          c2: Fp2.mul(c2, coeff),\r\n        }),\r\n      };\r\n    },\r\n    mulByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\r\n      c0: Fp6.mulByFp2(c0, rhs),\r\n      c1: Fp6.mulByFp2(c1, rhs),\r\n    }),\r\n    conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\r\n    // Sparse multiplication\r\n    mul014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\r\n      let t0 = Fp6.mul01(c0, o0, o1);\r\n      let t1 = Fp6.mul1(c1, o4);\r\n      return {\r\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\r\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\r\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\r\n      };\r\n    },\r\n    mul034: ({ c0, c1 }, o0: Fp2, o3: Fp2, o4: Fp2) => {\r\n      const a = Fp6.create({\r\n        c0: Fp2.mul(c0.c0, o0),\r\n        c1: Fp2.mul(c0.c1, o0),\r\n        c2: Fp2.mul(c0.c2, o0),\r\n      });\r\n      const b = Fp6.mul01(c1, o3, o4);\r\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\r\n      return {\r\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\r\n        c1: Fp6.sub(e, Fp6.add(a, b)),\r\n      };\r\n    },\r\n\r\n    // A cyclotomic group is a subgroup of Fp^n defined by\r\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\r\n    // The result of any pairing is in a cyclotomic subgroup\r\n    // https://eprint.iacr.org/2009/565.pdf\r\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\r\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\r\n    // https://eprint.iacr.org/2010/354.pdf\r\n    // https://eprint.iacr.org/2009/565.pdf\r\n    finalExponentiate: opts.Fp12finalExponentiate,\r\n  };\r\n\r\n  return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\r\n}\r\n", "/**\r\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\r\n * * Construct zk-SNARKs at the ~120-bit security\r\n * * Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\r\n *   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\r\n *\r\n * ### Summary\r\n * 1. BLS Relies on Bilinear Pairing (expensive)\r\n * 2. Private Keys: 32 bytes\r\n * 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\r\n * 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\r\n *     - The signature is a point on the G2 subgroup, which is defined over a finite field\r\n *       with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the\r\n *       complex numbers).\r\n *     - We also support reversed 96-byte pubkeys & 48-byte short signatures.\r\n * 5. The 12 stands for the Embedding degree.\r\n *\r\n * ### Formulas\r\n * - `P = pk x G` - public keys\r\n * - `S = pk x H(m)` - signing\r\n * - `e(P, H(m)) == e(G, S)` - verification using pairings\r\n * - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\r\n *\r\n * ### Compatibility and notes\r\n * 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\r\n * Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\r\n * 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\".\r\n * 3. Curve security level is about 120 bits as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\r\n * 4. Compatible with specs:\r\n *    [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\r\n *    [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),\r\n *    [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\r\n *\r\n * ### Params\r\n * To verify curve parameters, see\r\n * [pairing-friendly-curves spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11).\r\n * Basic math is done over finite fields over p.\r\n * More complicated math is done over polynominal extension fields.\r\n * To simplify calculations in Fp12, we construct extension tower:\r\n *\r\n * Embedding degree (k): 12\r\n * Seed (X): -15132376222941642752\r\n * Fr:  (x⁴-x²+1)\r\n * Fp: ((x-1)² ⋅ r(x)/3+x)\r\n * (E/Fp): Y²=X³+4\r\n * (Eₜ/Fp²): Y² = X³+4(u+1) (M-type twist)\r\n * Ate loop size: X\r\n *\r\n * ### Towers\r\n * - Fp₁₂ = Fp₆² => Fp₂³\r\n * - Fp(u) / (u² - β) where β = -1\r\n * - Fp₂(v) / (v³ - ξ) where ξ = u + 1\r\n * - Fp₆(w) / (w² - γ) where γ = v\r\n * - Fp²[u] = Fp/u²+1\r\n * - Fp⁶[v] = Fp²/v³-1-u\r\n * - Fp¹²[w] = Fp⁶/w²-v\r\n *\r\n * @todo construct bls & bn fp/fr from seed.\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { randomBytes } from '@noble/hashes/utils';\r\nimport { bls, type CurveFn } from './abstract/bls.js';\r\nimport * as mod from './abstract/modular.js';\r\nimport {\r\n  bitGet,\r\n  bitLen,\r\n  bytesToHex,\r\n  bytesToNumberBE,\r\n  concatBytes as concatB,\r\n  ensureBytes,\r\n  type Hex,\r\n  numberToBytesBE,\r\n} from './abstract/utils.js';\r\n// Types\r\nimport { isogenyMap } from './abstract/hash-to-curve.js';\r\nimport type { Fp, Fp12, Fp2, Fp6 } from './abstract/tower.js';\r\nimport { psiFrobenius, tower12 } from './abstract/tower.js';\r\nimport {\r\n  type AffinePoint,\r\n  mapToCurveSimpleSWU,\r\n  type ProjPointType,\r\n} from './abstract/weierstrass.js';\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\n\r\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\r\nconst BLS_X = BigInt('0xd201000000010000');\r\nconst BLS_X_LEN = bitLen(BLS_X);\r\n\r\n// CURVE FIELDS\r\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({\r\n  // Order of Fp\r\n  ORDER: BigInt(\r\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\r\n  ),\r\n  // Finite extension field over irreducible polynominal.\r\n  // Fp(u) / (u² - β) where β = -1\r\n  FP2_NONRESIDUE: [_1n, _1n],\r\n  Fp2mulByB: ({ c0, c1 }) => {\r\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\r\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\r\n    // (T0-T1) + (T0+T1)*i\r\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\r\n  },\r\n  // Fp12\r\n  // A cyclotomic group is a subgroup of Fp^n defined by\r\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\r\n  // The result of any pairing is in a cyclotomic subgroup\r\n  // https://eprint.iacr.org/2009/565.pdf\r\n  Fp12cyclotomicSquare: ({ c0, c1 }): Fp12 => {\r\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\r\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\r\n    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\r\n    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\r\n    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\r\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\r\n    return {\r\n      c0: Fp6.create({\r\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\r\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\r\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\r\n      }), // 2 * (T7 - c0c2)  + T7\r\n      c1: Fp6.create({\r\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\r\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\r\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\r\n      }),\r\n    }; // 2 * (T6 + c1c2) + T6\r\n  },\r\n  Fp12cyclotomicExp(num, n) {\r\n    let z = Fp12.ONE;\r\n    for (let i = BLS_X_LEN - 1; i >= 0; i--) {\r\n      z = Fp12._cyclotomicSquare(z);\r\n      if (bitGet(n, i)) z = Fp12.mul(z, num);\r\n    }\r\n    return z;\r\n  },\r\n  // https://eprint.iacr.org/2010/354.pdf\r\n  // https://eprint.iacr.org/2009/565.pdf\r\n  Fp12finalExponentiate: (num) => {\r\n    const x = BLS_X;\r\n    // this^(q⁶) / this\r\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\r\n    // t0^(q²) * t0\r\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\r\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\r\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\r\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\r\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\r\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\r\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\r\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\r\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\r\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\r\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\r\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\r\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\r\n  },\r\n});\r\n\r\n// Finite field over r.\r\n// This particular field is not used anywhere in bls12-381, but it is still useful.\r\nconst Fr = mod.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\r\n\r\n// END OF CURVE FIELDS\r\n\r\n// HashToCurve\r\n\r\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\r\nconst isogenyMapG2 = isogenyMap(\r\n  Fp2,\r\n  [\r\n    // xNum\r\n    [\r\n      [\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\r\n      ],\r\n      [\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\r\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\r\n      ],\r\n      [\r\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\r\n        '0x0',\r\n      ],\r\n    ],\r\n    // xDen\r\n    [\r\n      [\r\n        '0x0',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\r\n      ],\r\n      [\r\n        '0xc',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\r\n      ],\r\n      ['0x1', '0x0'], // LAST 1\r\n    ],\r\n    // yNum\r\n    [\r\n      [\r\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\r\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\r\n      ],\r\n      [\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\r\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\r\n      ],\r\n      [\r\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\r\n        '0x0',\r\n      ],\r\n    ],\r\n    // yDen\r\n    [\r\n      [\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\r\n      ],\r\n      [\r\n        '0x12',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\r\n      ],\r\n      ['0x1', '0x0'], // LAST 1\r\n    ],\r\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))) as [Fp2[], Fp2[], Fp2[], Fp2[]]\r\n);\r\n// 11-isogeny map from E' to E\r\nconst isogenyMapG1 = isogenyMap(\r\n  Fp,\r\n  [\r\n    // xNum\r\n    [\r\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\r\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\r\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\r\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\r\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\r\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\r\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\r\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\r\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\r\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\r\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\r\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\r\n    ],\r\n    // xDen\r\n    [\r\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\r\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\r\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\r\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\r\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\r\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\r\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\r\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\r\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\r\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\r\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n    // yNum\r\n    [\r\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\r\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\r\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\r\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\r\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\r\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\r\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\r\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\r\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\r\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\r\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\r\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\r\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\r\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\r\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\r\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\r\n    ],\r\n    // yDen\r\n    [\r\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\r\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\r\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\r\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\r\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\r\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\r\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\r\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\r\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\r\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\r\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\r\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\r\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\r\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\r\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\r\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\r\n);\r\n\r\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\r\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\r\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\r\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\r\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\r\n});\r\n// Optimized SWU Map - Fp to G1\r\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\r\n  A: Fp.create(\r\n    BigInt(\r\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\r\n    )\r\n  ),\r\n  B: Fp.create(\r\n    BigInt(\r\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\r\n    )\r\n  ),\r\n  Z: Fp.create(BigInt(11)),\r\n});\r\n\r\n// Endomorphisms (for fast cofactor clearing)\r\n// Ψ(P) endomorphism\r\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\r\n\r\n// Default hash_to_field options are for hash to G2.\r\n//\r\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\r\n// Parameter values come from section 8.8.2 of the spec.\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\r\n//\r\n// Base field F is GF(p^m)\r\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\r\n// m = 2 (or 1 for G1 see section 8.8.1)\r\n// k = 128\r\nconst htfDefaults = Object.freeze({\r\n  // DST: a domain separation tag\r\n  // defined in section 2.2.5\r\n  // Use utils.getDSTLabel(), utils.setDSTLabel(value)\r\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\r\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\r\n  // p: the characteristic of F\r\n  //    where F is a finite field of characteristic p and order q = p^m\r\n  p: Fp.ORDER,\r\n  // m: the extension degree of F, m >= 1\r\n  //     where F is a finite field of characteristic p and order q = p^m\r\n  m: 2,\r\n  // k: the target security level for the suite in bits\r\n  // defined in section 5.1\r\n  k: 128,\r\n  // option to use a message that has already been processed by\r\n  // expand_message_xmd\r\n  expand: 'xmd',\r\n  // Hash functions for: expand_message_xmd is appropriate for use with a\r\n  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\r\n  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\r\n  hash: sha256,\r\n} as const);\r\n\r\n// Encoding utils\r\n// Point on G1 curve: (x, y)\r\n\r\n// Compressed point of infinity\r\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\r\n\r\nfunction parseMask(bytes: Uint8Array) {\r\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\r\n  bytes = bytes.slice();\r\n  const mask = bytes[0] & 0b1110_0000;\r\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\r\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\r\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\r\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\r\n  return { compressed, infinity, sort, value: bytes };\r\n}\r\n\r\nfunction setMask(\r\n  bytes: Uint8Array,\r\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\r\n) {\r\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\r\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\r\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\r\n  if (mask.sort) bytes[0] |= 0b0010_0000;\r\n  return bytes;\r\n}\r\n\r\nfunction signatureG1ToRawBytes(point: ProjPointType<Fp>) {\r\n  point.assertValidity();\r\n  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\r\n  const { x, y } = point.toAffine();\r\n  if (isZero) return COMPRESSED_ZERO.slice();\r\n  const P = Fp.ORDER;\r\n  const sort = Boolean((y * _2n) / P);\r\n  return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\r\n}\r\n\r\nfunction signatureG2ToRawBytes(point: ProjPointType<Fp2>) {\r\n  // NOTE: by some reasons it was missed in bls12-381, looks like bug\r\n  point.assertValidity();\r\n  const len = Fp.BYTES;\r\n  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\r\n    return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\r\n  const { x, y } = point.toAffine();\r\n  const { re: x0, im: x1 } = Fp2.reim(x);\r\n  const { re: y0, im: y1 } = Fp2.reim(y);\r\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\r\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\r\n  const z2 = x0;\r\n  return concatB(\r\n    setMask(numberToBytesBE(x1, len), { sort, compressed: true }),\r\n    numberToBytesBE(z2, len)\r\n  );\r\n}\r\n\r\n/**\r\n * bls12-381 pairing-friendly curve.\r\n * @example\r\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\r\n * // G1 keys, G2 signatures\r\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\r\n * const message = '64726e3da8';\r\n * const publicKey = bls.getPublicKey(privateKey);\r\n * const signature = bls.sign(message, privateKey);\r\n * const isValid = bls.verify(signature, message, publicKey);\r\n */\r\nexport const bls12_381: CurveFn = bls({\r\n  // Fields\r\n  fields: {\r\n    Fp,\r\n    Fp2,\r\n    Fp6,\r\n    Fp12,\r\n    Fr,\r\n  },\r\n  // G1 is the order-q subgroup of E1(Fp) : y² = x³ + 4, #E1(Fp) = h1q, where\r\n  // characteristic; z + (z⁴ - z² + 1)(z - 1)²/3\r\n  G1: {\r\n    Fp,\r\n    // cofactor; (z - 1)²/3\r\n    h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\r\n    // generator's coordinates\r\n    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\r\n    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\r\n    Gx: BigInt(\r\n      '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\r\n    ),\r\n    Gy: BigInt(\r\n      '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\r\n    ),\r\n    a: Fp.ZERO,\r\n    b: _4n,\r\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\r\n    wrapPrivateKey: true,\r\n    allowInfinityPoint: true,\r\n    // Checks is the point resides in prime-order subgroup.\r\n    // point.isTorsionFree() should return true for valid points\r\n    // It returns false for shitty points.\r\n    // https://eprint.iacr.org/2021/1130.pdf\r\n    isTorsionFree: (c, point): boolean => {\r\n      // φ endomorphism\r\n      const cubicRootOfUnityModP = BigInt(\r\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n      );\r\n      const phi = new c(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\r\n\r\n      // todo: unroll\r\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\r\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\r\n      return u2P.equals(phi);\r\n\r\n      // https://eprint.iacr.org/2019/814.pdf\r\n      // (z² − 1)/3\r\n      // const c1 = BigInt('0x396c8c005555e1560000000055555555');\r\n      // const P = this;\r\n      // const S = P.sigma();\r\n      // const Q = S.double();\r\n      // const S2 = S.sigma();\r\n      // // [(z² − 1)/3](2σ(P) − P − σ²(P)) − σ²(P) = O\r\n      // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);\r\n      // const C = left.subtract(S2);\r\n      // return C.isZero();\r\n    },\r\n    // Clear cofactor of G1\r\n    // https://eprint.iacr.org/2019/403\r\n    clearCofactor: (_c, point) => {\r\n      // return this.multiplyUnsafe(CURVE.h);\r\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\r\n    },\r\n    mapToCurve: (scalars: bigint[]) => {\r\n      const { x, y } = G1_SWU(Fp.create(scalars[0]));\r\n      return isogenyMapG1(x, y);\r\n    },\r\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp> => {\r\n      const { compressed, infinity, sort, value } = parseMask(bytes);\r\n      if (value.length === 48 && compressed) {\r\n        // TODO: Fp.bytes\r\n        const P = Fp.ORDER;\r\n        const compressedValue = bytesToNumberBE(value);\r\n        // Zero\r\n        const x = Fp.create(compressedValue & Fp.MASK);\r\n        if (infinity) {\r\n          if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');\r\n          return { x: _0n, y: _0n };\r\n        }\r\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\r\n        let y = Fp.sqrt(right);\r\n        if (!y) throw new Error('invalid compressed G1 point');\r\n        if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\r\n        return { x: Fp.create(x), y: Fp.create(y) };\r\n      } else if (value.length === 96 && !compressed) {\r\n        // Check if the infinity flag is set\r\n        const x = bytesToNumberBE(value.subarray(0, Fp.BYTES));\r\n        const y = bytesToNumberBE(value.subarray(Fp.BYTES));\r\n        if (infinity) {\r\n          if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\r\n          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\r\n        }\r\n        return { x: Fp.create(x), y: Fp.create(y) };\r\n      } else {\r\n        throw new Error('invalid point G1, expected 48/96 bytes');\r\n      }\r\n    },\r\n    toBytes: (c, point, isCompressed) => {\r\n      const isZero = point.equals(c.ZERO);\r\n      const { x, y } = point.toAffine();\r\n      if (isCompressed) {\r\n        if (isZero) return COMPRESSED_ZERO.slice();\r\n        const P = Fp.ORDER;\r\n        const sort = Boolean((y * _2n) / P);\r\n        return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\r\n      } else {\r\n        if (isZero) {\r\n          // 2x PUBLIC_KEY_LENGTH\r\n          const x = concatB(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\r\n          return x;\r\n        } else {\r\n          return concatB(numberToBytesBE(x, Fp.BYTES), numberToBytesBE(y, Fp.BYTES));\r\n        }\r\n      }\r\n    },\r\n    ShortSignature: {\r\n      fromHex(hex: Hex): ProjPointType<Fp> {\r\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\r\n        const P = Fp.ORDER;\r\n        const compressedValue = bytesToNumberBE(value);\r\n        // Zero\r\n        if (infinity) return bls12_381.G1.ProjectivePoint.ZERO;\r\n        const x = Fp.create(compressedValue & Fp.MASK);\r\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\r\n        let y = Fp.sqrt(right);\r\n        if (!y) throw new Error('invalid compressed G1 point');\r\n        const aflag = BigInt(sort);\r\n        if ((y * _2n) / P !== aflag) y = Fp.neg(y);\r\n        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\r\n        point.assertValidity();\r\n        return point;\r\n      },\r\n      toRawBytes(point: ProjPointType<Fp>) {\r\n        return signatureG1ToRawBytes(point);\r\n      },\r\n      toHex(point: ProjPointType<Fp>) {\r\n        return bytesToHex(signatureG1ToRawBytes(point));\r\n      },\r\n    },\r\n  },\r\n  // G2 is the order-q subgroup of E2(Fp²) : y² = x³+4(1+√−1),\r\n  // where Fp2 is Fp[√−1]/(x2+1). #E2(Fp2 ) = h2q, where\r\n  // G² - 1\r\n  // h2q\r\n  G2: {\r\n    Fp: Fp2,\r\n    // cofactor\r\n    h: BigInt(\r\n      '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\r\n    ),\r\n    Gx: Fp2.fromBigTuple([\r\n      BigInt(\r\n        '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\r\n      ),\r\n      BigInt(\r\n        '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\r\n      ),\r\n    ]),\r\n    // y =\r\n    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\r\n    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\r\n    Gy: Fp2.fromBigTuple([\r\n      BigInt(\r\n        '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\r\n      ),\r\n      BigInt(\r\n        '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\r\n      ),\r\n    ]),\r\n    a: Fp2.ZERO,\r\n    b: Fp2.fromBigTuple([_4n, _4n]),\r\n    hEff: BigInt(\r\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\r\n    ),\r\n    htfDefaults: { ...htfDefaults },\r\n    wrapPrivateKey: true,\r\n    allowInfinityPoint: true,\r\n    mapToCurve: (scalars: bigint[]) => {\r\n      const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\r\n      return isogenyMapG2(x, y);\r\n    },\r\n    // Checks is the point resides in prime-order subgroup.\r\n    // point.isTorsionFree() should return true for valid points\r\n    // It returns false for shitty points.\r\n    // https://eprint.iacr.org/2021/1130.pdf\r\n    isTorsionFree: (c, P): boolean => {\r\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\r\n      // Older version: https://eprint.iacr.org/2019/814.pdf\r\n      // Ψ²(P) => Ψ³(P) => [z]Ψ³(P) where z = -x => [z]Ψ³(P) - Ψ²(P) + P == O\r\n      // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();\r\n    },\r\n    // Maps the point into the prime-order subgroup G2.\r\n    // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\r\n    // https://eprint.iacr.org/2017/419.pdf\r\n    // prettier-ignore\r\n    clearCofactor: (c, P) => {\r\n      const x = BLS_X;\r\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\r\n      let t2 = G2psi(c, P);                   // Ψ(P)\r\n      let t3 = P.double();                    // 2P\r\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\r\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\r\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\r\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\r\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\r\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\r\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\r\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\r\n    },\r\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp2> => {\r\n      const { compressed, infinity, sort, value } = parseMask(bytes);\r\n      if (\r\n        (!compressed && !infinity && sort) || // 00100000\r\n        (!compressed && infinity && sort) || // 01100000\r\n        (sort && infinity && compressed) // 11100000\r\n      ) {\r\n        throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\r\n      }\r\n      const L = Fp.BYTES;\r\n      const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\r\n      if (value.length === 96 && compressed) {\r\n        const b = bls12_381.params.G2b;\r\n        const P = Fp.ORDER;\r\n        if (infinity) {\r\n          // check that all bytes are 0\r\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\r\n            throw new Error('invalid compressed G2 point');\r\n          }\r\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\r\n        }\r\n        const x_1 = slc(value, 0, L);\r\n        const x_0 = slc(value, L, 2 * L);\r\n        const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\r\n        const right = Fp2.add(Fp2.pow(x, _3n), b); // y² = x³ + 4 * (u+1) = x³ + b\r\n        let y = Fp2.sqrt(right);\r\n        const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\r\n        y = sort && Y_bit > 0 ? y : Fp2.neg(y);\r\n        return { x, y };\r\n      } else if (value.length === 192 && !compressed) {\r\n        if (infinity) {\r\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\r\n            throw new Error('invalid uncompressed G2 point');\r\n          }\r\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\r\n        }\r\n        const x1 = slc(value, 0, L);\r\n        const x0 = slc(value, L, 2 * L);\r\n        const y1 = slc(value, 2 * L, 3 * L);\r\n        const y0 = slc(value, 3 * L, 4 * L);\r\n        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\r\n      } else {\r\n        throw new Error('invalid point G2, expected 96/192 bytes');\r\n      }\r\n    },\r\n    toBytes: (c, point, isCompressed) => {\r\n      const { BYTES: len, ORDER: P } = Fp;\r\n      const isZero = point.equals(c.ZERO);\r\n      const { x, y } = point.toAffine();\r\n      if (isCompressed) {\r\n        if (isZero) return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\r\n        const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\r\n        return concatB(\r\n          setMask(numberToBytesBE(x.c1, len), { compressed: true, sort: flag }),\r\n          numberToBytesBE(x.c0, len)\r\n        );\r\n      } else {\r\n        if (isZero) return concatB(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\r\n        const { re: x0, im: x1 } = Fp2.reim(x);\r\n        const { re: y0, im: y1 } = Fp2.reim(y);\r\n        return concatB(\r\n          numberToBytesBE(x1, len),\r\n          numberToBytesBE(x0, len),\r\n          numberToBytesBE(y1, len),\r\n          numberToBytesBE(y0, len)\r\n        );\r\n      }\r\n    },\r\n    Signature: {\r\n      // TODO: Optimize, it's very slow because of sqrt.\r\n      fromHex(hex: Hex): ProjPointType<Fp2> {\r\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\r\n        const P = Fp.ORDER;\r\n        const half = value.length / 2;\r\n        if (half !== 48 && half !== 96)\r\n          throw new Error('invalid compressed signature length, must be 96 or 192');\r\n        const z1 = bytesToNumberBE(value.slice(0, half));\r\n        const z2 = bytesToNumberBE(value.slice(half));\r\n        // Indicates the infinity point\r\n        if (infinity) return bls12_381.G2.ProjectivePoint.ZERO;\r\n        const x1 = Fp.create(z1 & Fp.MASK);\r\n        const x2 = Fp.create(z2);\r\n        const x = Fp2.create({ c0: x2, c1: x1 });\r\n        const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y² = x³ + 4\r\n        // The slow part\r\n        let y = Fp2.sqrt(y2);\r\n        if (!y) throw new Error('Failed to find a square root');\r\n\r\n        // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\r\n        // If y1 happens to be zero, then use the bit of y0\r\n        const { re: y0, im: y1 } = Fp2.reim(y);\r\n        const aflag1 = BigInt(sort);\r\n        const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\r\n        const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\r\n        if (isGreater || isZero) y = Fp2.neg(y);\r\n        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\r\n        point.assertValidity();\r\n        return point;\r\n      },\r\n      toRawBytes(point: ProjPointType<Fp2>) {\r\n        return signatureG2ToRawBytes(point);\r\n      },\r\n      toHex(point: ProjPointType<Fp2>) {\r\n        return bytesToHex(signatureG2ToRawBytes(point));\r\n      },\r\n    },\r\n  },\r\n  params: {\r\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\r\n    r: Fr.ORDER, // order; z⁴ − z² + 1; CURVE.n from other curves\r\n    xNegative: true,\r\n    twistType: 'multiplicative',\r\n  },\r\n  htfDefaults,\r\n  hash: sha256,\r\n  randomBytes,\r\n});\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex, toHex } from '@mysten/bcs';\nimport { bcs } from '@mysten/sui/bcs';\n\nexport const IBEEncryptions = bcs.enum('IBEEncryptions', {\n\tBonehFranklinBLS12381: bcs.struct('BonehFranklinBLS12381', {\n\t\tnonce: bcs.bytes(96),\n\t\tencryptedShares: bcs.vector(bcs.bytes(32)),\n\t\tencryptedRandomness: bcs.bytes(32),\n\t}),\n});\n\nexport const Ciphertext = bcs.enum('Ciphertext', {\n\tAes256Gcm: bcs.struct('Aes256Gcm', {\n\t\tblob: bcs.vector(bcs.U8),\n\t\taad: bcs.option(bcs.vector(bcs.U8)),\n\t}),\n\tHmac256Ctr: bcs.struct('Hmac256Ctr', {\n\t\tblob: bcs.vector(bcs.U8),\n\t\taad: bcs.option(bcs.vector(bcs.U8)),\n\t\tmac: bcs.bytes(32),\n\t}),\n\tPlain: bcs.struct('Plain', {}),\n});\n\n/**\n * The encrypted object format. Should be aligned with the Rust implementation.\n */\nexport const EncryptedObject = bcs.struct('EncryptedObject', {\n\tversion: bcs.U8,\n\tpackageId: bcs.Address,\n\tid: bcs.vector(bcs.U8).transform({\n\t\toutput: (val) => toHex(new Uint8Array(val)),\n\t\tinput: (val: string) => fromHex(val),\n\t}),\n\tservices: bcs.vector(bcs.tuple([bcs.Address, bcs.U8])),\n\tthreshold: bcs.U8,\n\tencryptedShares: IBEEncryptions,\n\tciphertext: Ciphertext,\n});\n\n/**\n * The Move struct for the KeyServer object.\n */\nexport const KeyServerMove = bcs.struct('KeyServer', {\n\tid: bcs.Address,\n\tname: bcs.string(),\n\turl: bcs.string(),\n\tkeyType: bcs.u8(),\n\tpk: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SealError extends Error {}\n\nexport class UserError extends SealError {}\n\n// Errors returned by the Seal server\nexport class SealAPIError extends SealError {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic requestId?: string,\n\t\tpublic status?: number,\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic #generate(message: string, requestId: string, status?: number) {\n\t\tswitch (message) {\n\t\t\tcase 'InvalidPTB':\n\t\t\t\treturn new InvalidPTBError(requestId);\n\t\t\tcase 'InvalidPackage':\n\t\t\t\treturn new InvalidPackageError(requestId);\n\t\t\tcase 'NoAccess':\n\t\t\t\treturn new NoAccessError(requestId);\n\t\t\tcase 'InvalidCertificate':\n\t\t\t\treturn new ExpiredSessionKeyError(requestId);\n\t\t\tcase 'OldPackageVersion':\n\t\t\t\treturn new OldPackageError(requestId);\n\t\t\tcase 'InvalidSignature':\n\t\t\t\treturn new InvalidUserSignatureError(requestId);\n\t\t\tcase 'InvalidSessionSignature':\n\t\t\t\treturn new InvalidSessionKeySignatureError(requestId);\n\t\t\tcase 'Failure':\n\t\t\t\treturn new InternalError(requestId);\n\t\t\tdefault:\n\t\t\t\treturn new GeneralError(message, requestId, status);\n\t\t}\n\t}\n\n\tstatic async assertResponse(response: Response, requestId: string) {\n\t\tif (response.ok) {\n\t\t\treturn;\n\t\t}\n\t\tlet errorInstance: SealAPIError;\n\t\ttry {\n\t\t\tconst text = await response.text();\n\t\t\tconst error = JSON.parse(text)['error'];\n\t\t\terrorInstance = SealAPIError.#generate(error, requestId);\n\t\t} catch (e) {\n\t\t\t// If we can't parse the response as JSON or if it doesn't have the expected format,\n\t\t\t// fall back to using the status text\n\t\t\terrorInstance = new GeneralError(response.statusText, requestId, response.status);\n\t\t}\n\t\tthrow errorInstance;\n\t}\n}\n\n// Errors returned by the Seal server that indicate that the PTB is invalid\n\nexport class InvalidPTBError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('PTB does not conform to the expected format', requestId);\n\t}\n}\n\nexport class InvalidPackageError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Package ID used in PTB is invalid', requestId);\n\t}\n}\n\nexport class OldPackageError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('PTB must call the latest version of the package', requestId);\n\t}\n}\n\n// Errors returned by the Seal server that indicate that the user's signature is invalid\n\nexport class InvalidUserSignatureError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('User signature on the session key is invalid', requestId);\n\t}\n}\n\nexport class InvalidSessionKeySignatureError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Session key signature is invalid', requestId);\n\t}\n}\n\n/** Server error indicating that the user does not have access to one or more of the requested keys */\nexport class NoAccessError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('User does not have access to one or more of the requested keys', requestId);\n\t}\n}\n\n/** Server error indicating that the session key has expired */\nexport class ExpiredSessionKeyError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Session key has expired', requestId);\n\t}\n}\n\n/** Internal server error, caller should retry */\nexport class InternalError extends SealAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('Internal server error, caller should retry', requestId);\n\t}\n}\n\n/** General server errors that are not specific to the Seal API (e.g., 404 \"Not Found\") */\nexport class GeneralError extends SealAPIError {}\n\n// Errors returned by the SDK\nexport class InvalidPersonalMessageSignatureError extends UserError {}\nexport class InvalidGetObjectError extends UserError {}\nexport class UnsupportedFeatureError extends UserError {}\nexport class UnsupportedNetworkError extends UserError {}\nexport class InvalidKeyServerError extends UserError {}\nexport class InvalidCiphertextError extends UserError {}\nexport class InvalidThresholdError extends UserError {}\nexport class InconsistentKeyServersError extends UserError {}\n\nexport function toMajorityError(errors: Error[]): Error {\n\tlet maxCount = 0;\n\tlet majorityError = errors[0];\n\tconst counts = new Map<string, number>();\n\tfor (const error of errors) {\n\t\tconst errorName = error.constructor.name;\n\t\tconst newCount = (counts.get(errorName) || 0) + 1;\n\t\tcounts.set(errorName, newCount);\n\n\t\tif (newCount > maxCount) {\n\t\t\tmaxCount = newCount;\n\t\t\tmajorityError = error;\n\t\t}\n\t}\n\n\treturn majorityError;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toHex } from '@mysten/bcs';\nimport type { Fp2, Fp12 } from '@noble/curves/abstract/tower';\nimport type { ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { bls12_381 } from '@noble/curves/bls12-381';\n\nexport class G1Element {\n\tpoint: ProjPointType<bigint>;\n\n\tconstructor(point: ProjPointType<bigint>) {\n\t\tthis.point = point;\n\t}\n\n\tstatic generator(): G1Element {\n\t\treturn new G1Element(bls12_381.G1.ProjectivePoint.BASE);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): G1Element {\n\t\treturn new G1Element(bls12_381.G1.ProjectivePoint.fromHex(toHex(bytes)));\n\t}\n\n\ttoBytes(): Uint8Array {\n\t\treturn this.point.toRawBytes();\n\t}\n\n\tmultiply(scalar: Scalar): G1Element {\n\t\treturn new G1Element(this.point.multiply(scalar.scalar));\n\t}\n\n\tadd(other: G1Element): G1Element {\n\t\treturn new G1Element(this.point.add(other.point));\n\t}\n\n\tsubtract(other: G1Element): G1Element {\n\t\treturn new G1Element(this.point.subtract(other.point));\n\t}\n\n\tstatic hashToCurve(data: Uint8Array): G1Element {\n\t\treturn new G1Element(\n\t\t\tbls12_381.G1.ProjectivePoint.fromAffine(bls12_381.G1.hashToCurve(data).toAffine()),\n\t\t);\n\t}\n\n\tpairing(other: G2Element): GTElement {\n\t\treturn new GTElement(bls12_381.pairing(this.point, other.point));\n\t}\n}\n\nexport class G2Element {\n\tpoint: ProjPointType<Fp2>;\n\n\tconstructor(point: ProjPointType<Fp2>) {\n\t\tthis.point = point;\n\t}\n\n\tstatic generator(): G2Element {\n\t\treturn new G2Element(bls12_381.G2.ProjectivePoint.BASE);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): G2Element {\n\t\treturn new G2Element(bls12_381.G2.ProjectivePoint.fromHex(toHex(bytes)));\n\t}\n\n\ttoBytes(): Uint8Array {\n\t\treturn this.point.toRawBytes();\n\t}\n\n\tmultiply(scalar: Scalar): G2Element {\n\t\treturn new G2Element(this.point.multiply(scalar.scalar));\n\t}\n\n\tadd(other: G2Element): G2Element {\n\t\treturn new G2Element(this.point.add(other.point));\n\t}\n\n\thashToCurve(data: Uint8Array): G2Element {\n\t\treturn new G2Element(\n\t\t\tbls12_381.G2.ProjectivePoint.fromAffine(bls12_381.G2.hashToCurve(data).toAffine()),\n\t\t);\n\t}\n}\n\nexport class GTElement {\n\telement: Fp12;\n\n\tconstructor(element: Fp12) {\n\t\tthis.element = element;\n\t}\n\n\ttoBytes(): Uint8Array {\n\t\treturn bls12_381.fields.Fp12.toBytes(this.element);\n\t}\n}\n\nexport class Scalar {\n\tscalar: bigint;\n\n\tconstructor(scalar: bigint) {\n\t\tthis.scalar = scalar;\n\t}\n\n\tstatic random(): Scalar {\n\t\treturn Scalar.fromBytes(bls12_381.utils.randomPrivateKey());\n\t}\n\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(bls12_381.fields.Fr.toBytes(this.scalar));\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array): Scalar {\n\t\treturn new Scalar(bls12_381.fields.Fr.fromBytes(bytes));\n\t}\n\n\tstatic fromNumber(num: number): Scalar {\n\t\treturn new Scalar(BigInt(num));\n\t}\n}\n", "/**\r\n * HKDF (RFC 5869): extract + expand in one step.\r\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\r\n * @module\r\n */\r\nimport { ahash, anumber } from './_assert.js';\r\nimport { hmac } from './hmac.js';\r\nimport { type CHash, type Input, toBytes } from './utils.js';\r\n\r\n/**\r\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\r\n * Arguments position differs from spec (IKM is first one, since it is not optional)\r\n * @param hash - hash function that would be used (e.g. sha256)\r\n * @param ikm - input keying material, the initial key\r\n * @param salt - optional salt value (a non-secret random value)\r\n */\r\nexport function extract(hash: CHash, ikm: Input, salt?: Input): Uint8Array {\r\n  ahash(hash);\r\n  // NOTE: some libraries treat zero-length array as 'not provided';\r\n  // we don't, since we have undefined as 'not provided'\r\n  // https://github.com/RustCrypto/KDFs/issues/15\r\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen);\r\n  return hmac(hash, toBytes(salt), toBytes(ikm));\r\n}\r\n\r\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\r\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\r\n\r\n/**\r\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\r\n * @param hash - hash function that would be used (e.g. sha256)\r\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\r\n * @param info - optional context and application specific information (can be a zero-length string)\r\n * @param length - length of output keying material in bytes\r\n */\r\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32): Uint8Array {\r\n  ahash(hash);\r\n  anumber(length);\r\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\r\n  const blocks = Math.ceil(length / hash.outputLen);\r\n  if (info === undefined) info = EMPTY_BUFFER;\r\n  // first L(ength) octets of T\r\n  const okm = new Uint8Array(blocks * hash.outputLen);\r\n  // Re-use HMAC instance between blocks\r\n  const HMAC = hmac.create(hash, prk);\r\n  const HMACTmp = HMAC._cloneInto();\r\n  const T = new Uint8Array(HMAC.outputLen);\r\n  for (let counter = 0; counter < blocks; counter++) {\r\n    HKDF_COUNTER[0] = counter + 1;\r\n    // T(0) = empty string (zero length)\r\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\r\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\r\n      .update(info)\r\n      .update(HKDF_COUNTER)\r\n      .digestInto(T);\r\n    okm.set(T, hash.outputLen * counter);\r\n    HMAC._cloneInto(HMACTmp);\r\n  }\r\n  HMAC.destroy();\r\n  HMACTmp.destroy();\r\n  T.fill(0);\r\n  HKDF_COUNTER.fill(0);\r\n  return okm.slice(0, length);\r\n}\r\n\r\n/**\r\n * HKDF (RFC 5869): derive keys from an initial input.\r\n * Combines hkdf_extract + hkdf_expand in one step\r\n * @param hash - hash function that would be used (e.g. sha256)\r\n * @param ikm - input keying material, the initial key\r\n * @param salt - optional salt value (a non-secret random value)\r\n * @param info - optional context and application specific information (can be a zero-length string)\r\n * @param length - length of output keying material in bytes\r\n * @example\r\n * import { hkdf } from '@noble/hashes/hkdf';\r\n * import { sha256 } from '@noble/hashes/sha2';\r\n * import { randomBytes } from '@noble/hashes/utils';\r\n * const inputKey = randomBytes(32);\r\n * const salt = randomBytes(32);\r\n * const info = 'application-key';\r\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\r\n */\r\nexport const hkdf = (\r\n  hash: CHash,\r\n  ikm: Input,\r\n  salt: Input | undefined,\r\n  info: Input | undefined,\r\n  length: number\r\n): Uint8Array => expand(hash, extract(hash, ikm, salt), info, length);\r\n", "/**\r\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\r\n * Different from older hashes, the internal state is bigger than output size.\r\n *\r\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\r\n * [Website](https://keccak.team/keccak.html),\r\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\r\n *\r\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\r\n * @module\r\n */\r\nimport { abytes, aexists, anumber, aoutput } from './_assert.js';\r\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\r\nimport {\r\n  byteSwap32,\r\n  Hash,\r\n  isLE,\r\n  toBytes,\r\n  u32,\r\n  wrapConstructor,\r\n  wrapXOFConstructorWithOpts,\r\n  type CHash,\r\n  type CHashXO,\r\n  type HashXOF,\r\n  type Input,\r\n} from './utils.js';\r\n\r\n// Various per round constants calculations\r\nconst SHA3_PI: number[] = [];\r\nconst SHA3_ROTL: number[] = [];\r\nconst _SHA3_IOTA: bigint[] = [];\r\nconst _0n = /* @__PURE__ */ BigInt(0);\r\nconst _1n = /* @__PURE__ */ BigInt(1);\r\nconst _2n = /* @__PURE__ */ BigInt(2);\r\nconst _7n = /* @__PURE__ */ BigInt(7);\r\nconst _256n = /* @__PURE__ */ BigInt(256);\r\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\r\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\r\n  // Pi\r\n  [x, y] = [y, (2 * x + 3 * y) % 5];\r\n  SHA3_PI.push(2 * (5 * y + x));\r\n  // Rotational\r\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\r\n  // Iota\r\n  let t = _0n;\r\n  for (let j = 0; j < 7; j++) {\r\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\r\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\r\n  }\r\n  _SHA3_IOTA.push(t);\r\n}\r\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\r\n\r\n// Left rotation (without 0, 32, 64)\r\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\r\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\r\n\r\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\r\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\r\n  const B = new Uint32Array(5 * 2);\r\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\r\n  for (let round = 24 - rounds; round < 24; round++) {\r\n    // Theta θ\r\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\r\n    for (let x = 0; x < 10; x += 2) {\r\n      const idx1 = (x + 8) % 10;\r\n      const idx0 = (x + 2) % 10;\r\n      const B0 = B[idx0];\r\n      const B1 = B[idx0 + 1];\r\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\r\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\r\n      for (let y = 0; y < 50; y += 10) {\r\n        s[x + y] ^= Th;\r\n        s[x + y + 1] ^= Tl;\r\n      }\r\n    }\r\n    // Rho (ρ) and Pi (π)\r\n    let curH = s[2];\r\n    let curL = s[3];\r\n    for (let t = 0; t < 24; t++) {\r\n      const shift = SHA3_ROTL[t];\r\n      const Th = rotlH(curH, curL, shift);\r\n      const Tl = rotlL(curH, curL, shift);\r\n      const PI = SHA3_PI[t];\r\n      curH = s[PI];\r\n      curL = s[PI + 1];\r\n      s[PI] = Th;\r\n      s[PI + 1] = Tl;\r\n    }\r\n    // Chi (χ)\r\n    for (let y = 0; y < 50; y += 10) {\r\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\r\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\r\n    }\r\n    // Iota (ι)\r\n    s[0] ^= SHA3_IOTA_H[round];\r\n    s[1] ^= SHA3_IOTA_L[round];\r\n  }\r\n  B.fill(0);\r\n}\r\n\r\n/** Keccak sponge function. */\r\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\r\n  protected state: Uint8Array;\r\n  protected pos = 0;\r\n  protected posOut = 0;\r\n  protected finished = false;\r\n  protected state32: Uint32Array;\r\n  protected destroyed = false;\r\n  // NOTE: we accept arguments in bytes instead of bits here.\r\n  constructor(\r\n    public blockLen: number,\r\n    public suffix: number,\r\n    public outputLen: number,\r\n    protected enableXOF = false,\r\n    protected rounds: number = 24\r\n  ) {\r\n    super();\r\n    // Can be passed from user as dkLen\r\n    anumber(outputLen);\r\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\r\n    // 0 < blockLen < 200\r\n    if (0 >= this.blockLen || this.blockLen >= 200)\r\n      throw new Error('Sha3 supports only keccak-f1600 function');\r\n    this.state = new Uint8Array(200);\r\n    this.state32 = u32(this.state);\r\n  }\r\n  protected keccak(): void {\r\n    if (!isLE) byteSwap32(this.state32);\r\n    keccakP(this.state32, this.rounds);\r\n    if (!isLE) byteSwap32(this.state32);\r\n    this.posOut = 0;\r\n    this.pos = 0;\r\n  }\r\n  update(data: Input): this {\r\n    aexists(this);\r\n    const { blockLen, state } = this;\r\n    data = toBytes(data);\r\n    const len = data.length;\r\n    for (let pos = 0; pos < len; ) {\r\n      const take = Math.min(blockLen - this.pos, len - pos);\r\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\r\n      if (this.pos === blockLen) this.keccak();\r\n    }\r\n    return this;\r\n  }\r\n  protected finish(): void {\r\n    if (this.finished) return;\r\n    this.finished = true;\r\n    const { state, suffix, pos, blockLen } = this;\r\n    // Do the padding\r\n    state[pos] ^= suffix;\r\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\r\n    state[blockLen - 1] ^= 0x80;\r\n    this.keccak();\r\n  }\r\n  protected writeInto(out: Uint8Array): Uint8Array {\r\n    aexists(this, false);\r\n    abytes(out);\r\n    this.finish();\r\n    const bufferOut = this.state;\r\n    const { blockLen } = this;\r\n    for (let pos = 0, len = out.length; pos < len; ) {\r\n      if (this.posOut >= blockLen) this.keccak();\r\n      const take = Math.min(blockLen - this.posOut, len - pos);\r\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\r\n      this.posOut += take;\r\n      pos += take;\r\n    }\r\n    return out;\r\n  }\r\n  xofInto(out: Uint8Array): Uint8Array {\r\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\r\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\r\n    return this.writeInto(out);\r\n  }\r\n  xof(bytes: number): Uint8Array {\r\n    anumber(bytes);\r\n    return this.xofInto(new Uint8Array(bytes));\r\n  }\r\n  digestInto(out: Uint8Array): Uint8Array {\r\n    aoutput(out, this);\r\n    if (this.finished) throw new Error('digest() was already called');\r\n    this.writeInto(out);\r\n    this.destroy();\r\n    return out;\r\n  }\r\n  digest(): Uint8Array {\r\n    return this.digestInto(new Uint8Array(this.outputLen));\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    this.state.fill(0);\r\n  }\r\n  _cloneInto(to?: Keccak): Keccak {\r\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\r\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\r\n    to.state32.set(this.state32);\r\n    to.pos = this.pos;\r\n    to.posOut = this.posOut;\r\n    to.finished = this.finished;\r\n    to.rounds = rounds;\r\n    // Suffix can change in cSHAKE\r\n    to.suffix = suffix;\r\n    to.outputLen = outputLen;\r\n    to.enableXOF = enableXOF;\r\n    to.destroyed = this.destroyed;\r\n    return to;\r\n  }\r\n}\r\n\r\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\r\n\r\n/** SHA3-224 hash function. */\r\nexport const sha3_224: CHash = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\r\n/** SHA3-256 hash function. Different from keccak-256. */\r\nexport const sha3_256: CHash = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\r\n/** SHA3-384 hash function. */\r\nexport const sha3_384: CHash = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\r\n/** SHA3-512 hash function. */\r\nexport const sha3_512: CHash = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\r\n\r\n/** keccak-224 hash function. */\r\nexport const keccak_224: CHash = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\r\n/** keccak-256 hash function. Different from SHA3-256. */\r\nexport const keccak_256: CHash = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\r\n/** keccak-384 hash function. */\r\nexport const keccak_384: CHash = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\r\n/** keccak-512 hash function. */\r\nexport const keccak_512: CHash = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\r\n\r\nexport type ShakeOpts = { dkLen?: number };\r\n\r\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\r\n    (opts: ShakeOpts = {}) =>\r\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\r\n  );\r\n\r\n/** SHAKE128 XOF with 128-bit security. */\r\nexport const shake128: CHashXO = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\r\n/** SHAKE256 XOF with 256-bit security. */\r\nexport const shake256: CHashXO = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nimport { G1Element } from './bls12381.js';\nimport type { G2Element, GTElement } from './bls12381.js';\n\n/**\n * The default key derivation function.\n *\n * @param element The GTElement to derive the key from.\n * @param info Optional context and application specific information.\n * @returns The derived key.\n */\nexport function kdf(\n\telement: GTElement,\n\tnonce: G2Element,\n\tid: Uint8Array,\n\tobjectId: string,\n\tindex: number,\n): Uint8Array {\n\t// This permutation flips the order of 6 pairs of coefficients of the GT element.\n\t// The permutation may be computed as:\n\t// for i in 0..3 {\n\t//   for j in 0..2 {\n\t//     PERMUTATION[i + j * 3] = i * 2 + j;\n\t//   }\n\t// }\n\tconst GT_ELEMENT_BYTE_LENGTH = 576;\n\tconst PERMUTATION = [0, 2, 4, 1, 3, 5];\n\tconst COEFFICIENT_SIZE = GT_ELEMENT_BYTE_LENGTH / PERMUTATION.length;\n\n\tconst bytes = element.toBytes();\n\tlet permutedBytes = new Uint8Array(GT_ELEMENT_BYTE_LENGTH);\n\tPERMUTATION.forEach((pi, i) => {\n\t\tpermutedBytes.set(\n\t\t\tbytes.slice(i * COEFFICIENT_SIZE, (i + 1) * COEFFICIENT_SIZE),\n\t\t\tpi * COEFFICIENT_SIZE,\n\t\t);\n\t});\n\tconst inputBytes = new Uint8Array([\n\t\t...permutedBytes,\n\t\t...nonce.toBytes(),\n\t\t...G1Element.hashToCurve(id).toBytes(),\n\t]);\n\tconst info = new Uint8Array([...fromHex(objectId), index]);\n\treturn hkdf(sha3_256, inputBytes, '', info, 32);\n}\n\nexport enum KeyPurpose {\n\tEncryptedRandomness,\n\tDEM,\n}\n\nexport function deriveKey(purpose: KeyPurpose, baseKey: Uint8Array): Uint8Array {\n\tswitch (purpose) {\n\t\tcase KeyPurpose.EncryptedRandomness:\n\t\t\treturn hmac(sha3_256, baseKey, new Uint8Array([0]));\n\t\tcase KeyPurpose.DEM:\n\t\t\treturn hmac(sha3_256, baseKey, new Uint8Array([1]));\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex, toHex } from '@mysten/bcs';\nimport { isValidSuiObjectId } from '@mysten/sui/utils';\n\nimport { UserError } from './error.js';\n\nexport function xor(a: Uint8Array, b: Uint8Array): Uint8Array {\n\tif (a.length !== b.length) {\n\t\tthrow new Error('Invalid input');\n\t}\n\treturn xorUnchecked(a, b);\n}\n\nexport function xorUnchecked(a: Uint8Array, b: Uint8Array): Uint8Array {\n\treturn a.map((ai, i) => ai ^ b[i]);\n}\n\n/**\n * Create a full ID concatenating DST || package ID || inner ID.\n * @param dst - The domain separation tag.\n * @param packageId - The package ID.\n * @param innerId - The inner ID.\n * @returns The full ID.\n */\nexport function createFullId(dst: Uint8Array, packageId: string, innerId: string): string {\n\tif (!isValidSuiObjectId(packageId)) {\n\t\tthrow new UserError(`Invalid package ID ${packageId}`);\n\t}\n\tconst packageIdBytes = fromHex(packageId);\n\tconst innerIdBytes = fromHex(innerId);\n\tconst fullId = new Uint8Array(1 + dst.length + packageIdBytes.length + innerIdBytes.length);\n\tfullId.set([dst.length], 0);\n\tfullId.set(dst, 1);\n\tfullId.set(packageIdBytes, 1 + dst.length);\n\tfullId.set(innerIdBytes, 1 + dst.length + packageIdBytes.length);\n\treturn toHex(fullId);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\n\nimport type { IBEEncryptions } from './bcs.js';\nimport type { GTElement } from './bls12381.js';\nimport { G1Element, G2Element, Scalar } from './bls12381.js';\nimport { kdf } from './kdf.js';\nimport type { KeyServer } from './key-server.js';\nimport { xor } from './utils.js';\n\n/**\n * The domain separation tag for the hash-to-group function.\n */\nexport const DST: Uint8Array = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-00');\n\n/**\n * The domain separation tag for the signing proof of possession.\n */\nexport const DST_POP: Uint8Array = new TextEncoder().encode('SUI-SEAL-IBE-BLS12381-POP-00');\n\n/**\n * The interface for the key servers.\n */\nexport abstract class IBEServers {\n\tobjectIds: string[];\n\n\tconstructor(objectIds: string[]) {\n\t\tthis.objectIds = objectIds;\n\t}\n\n\t/**\n\t * The number of key servers.\n\t */\n\tsize(): number {\n\t\treturn this.objectIds.length;\n\t}\n\n\t/**\n\t * Encrypt a batch of messages for the given identity.\n\t *\n\t * @param id The identity.\n\t * @param msgAndIndices The messages and the corresponding indices of the share being encrypted.\n\t * @returns The encrypted messages.\n\t */\n\tabstract encryptBatched(\n\t\tid: Uint8Array,\n\t\tmsgAndIndices: { msg: Uint8Array; index: number }[],\n\t\trandomnessKey: Uint8Array,\n\t): typeof IBEEncryptions.$inferType;\n}\n\n/**\n * Identity-based encryption based on the Boneh-Franklin IBE scheme.\n * This object represents a set of key servers that can be used to encrypt messages for a given identity.\n */\nexport class BonehFranklinBLS12381Services extends IBEServers {\n\treadonly publicKeys: G2Element[];\n\n\tconstructor(services: KeyServer[]) {\n\t\tsuper(services.map((service) => service.objectId));\n\t\tthis.publicKeys = services.map((service) => G2Element.fromBytes(service.pk));\n\t}\n\n\tencryptBatched(\n\t\tid: Uint8Array,\n\t\tmsgAndIndices: { msg: Uint8Array; index: number }[],\n\t\trandomnessKey: Uint8Array,\n\t): typeof IBEEncryptions.$inferType {\n\t\tif (this.publicKeys.length === 0 || this.publicKeys.length !== msgAndIndices.length) {\n\t\t\tthrow new Error('Invalid public keys');\n\t\t}\n\t\tconst [r, nonce, keys] = encapBatched(this.publicKeys, id);\n\t\tconst encryptedShares = msgAndIndices.map((msgAndIndex, i) =>\n\t\t\txor(msgAndIndex.msg, kdf(keys[i], nonce, id, this.objectIds[i], msgAndIndex.index)),\n\t\t);\n\t\tconst encryptedRandomness = xor(randomnessKey, r.toBytes());\n\n\t\treturn {\n\t\t\tBonehFranklinBLS12381: {\n\t\t\t\tnonce: nonce.toBytes(),\n\t\t\t\tencryptedShares,\n\t\t\t\tencryptedRandomness,\n\t\t\t},\n\t\t\t$kind: 'BonehFranklinBLS12381',\n\t\t};\n\t}\n\n\t/**\n\t * Returns true if the user secret key is valid for the given public key and id.\n\t * @param user_secret_key - The user secret key.\n\t * @param id - The identity.\n\t * @param public_key - The public key.\n\t * @returns True if the user secret key is valid for the given public key and id.\n\t */\n\tstatic verifyUserSecretKey(userSecretKey: G1Element, id: string, publicKey: G2Element): boolean {\n\t\tconst lhs = userSecretKey.pairing(G2Element.generator()).toBytes();\n\t\tconst rhs = G1Element.hashToCurve(fromHex(id)).pairing(publicKey).toBytes();\n\t\treturn lhs.length === rhs.length && lhs.every((value, index) => value === rhs[index]);\n\t}\n\n\t/**\n\t * Identity-based decryption.\n\t *\n\t * @param nonce The encryption nonce.\n\t * @param sk The user secret key.\n\t * @param ciphertext The encrypted message.\n\t * @param info An info parameter also included in the KDF.\n\t * @returns The decrypted message.\n\t */\n\tstatic decrypt(\n\t\tnonce: G2Element,\n\t\tsk: G1Element,\n\t\tciphertext: Uint8Array,\n\t\tid: Uint8Array,\n\t\t[objectId, index]: [string, number],\n\t): Uint8Array {\n\t\treturn xor(ciphertext, kdf(decap(nonce, sk), nonce, id, objectId, index));\n\t}\n}\n\n/**\n * Batched identity-based key-encapsulation mechanism: encapsulate multiple keys for given identity using different key servers.\n *\n * @param publicKeys Public keys for a set of key servers.\n * @param id The identity used to encapsulate the keys.\n * @returns A common nonce of the keys and a list of keys, 32 bytes each.\n */\nfunction encapBatched(publicKeys: G2Element[], id: Uint8Array): [Scalar, G2Element, GTElement[]] {\n\tif (publicKeys.length === 0) {\n\t\tthrow new Error('No public keys provided');\n\t}\n\tconst r = Scalar.random();\n\tconst nonce = G2Element.generator().multiply(r);\n\tconst gid = G1Element.hashToCurve(id).multiply(r);\n\treturn [r, nonce, publicKeys.map((public_key) => gid.pairing(public_key))];\n}\n\n/**\n * Decapsulate a key using a user secret key and the nonce.\n *\n * @param usk The user secret key.\n * @param nonce The nonce.\n * @returns The encapsulated key.\n */\nfunction decap(nonce: G2Element, usk: G1Element): GTElement {\n\treturn usk.pairing(nonce);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '0.3.5';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { fromBase64, fromHex } from '@mysten/bcs';\nimport type { SuiClient } from '@mysten/sui/client';\nimport { bls12_381 } from '@noble/curves/bls12-381';\n\nimport { KeyServerMove } from './bcs.js';\nimport {\n\tInvalidGetObjectError,\n\tSealAPIError,\n\tUnsupportedFeatureError,\n\tUnsupportedNetworkError,\n} from './error.js';\nimport { DST_POP } from './ibe.js';\nimport { PACKAGE_VERSION } from './version.js';\n\nexport type KeyServer = {\n\tobjectId: string;\n\tname: string;\n\turl: string;\n\tkeyType: KeyServerType;\n\tpk: Uint8Array;\n};\n\nexport enum KeyServerType {\n\tBonehFranklinBLS12381 = 0,\n}\n\n/**\n * Returns a static list of Seal key server object ids that the dapp can choose to use.\n * @param network - The network to use.\n * @returns The object id's of the key servers.\n */\nexport function getAllowlistedKeyServers(network: 'testnet' | 'mainnet'): string[] {\n\tif (network === 'testnet') {\n\t\treturn [\n\t\t\t'0xb35a7228d8cf224ad1e828c0217c95a5153bafc2906d6f9c178197dce26fbcf8',\n\t\t\t'0x2d6cde8a9d9a65bde3b0a346566945a63b4bfb70e9a06c41bdb70807e2502b06',\n\t\t];\n\t} else {\n\t\tthrow new UnsupportedNetworkError(`Unsupported network ${network}`);\n\t}\n}\n\n/**\n * Given a list of key server object IDs, returns a list of SealKeyServer\n * from onchain state containing name, objectId, URL and pk.\n *\n * @param objectIds - The key server object IDs.\n * @param client - The SuiClient to use.\n * @returns - An array of SealKeyServer.\n */\nexport async function retrieveKeyServers({\n\tobjectIds,\n\tclient,\n}: {\n\tobjectIds: string[];\n\tclient: SuiClient;\n}): Promise<KeyServer[]> {\n\t// todo: do not fetch the same object ID if this is fetched before.\n\treturn await Promise.all(\n\t\tobjectIds.map(async (objectId) => {\n\t\t\tconst res = await client.getObject({\n\t\t\t\tid: objectId,\n\t\t\t\toptions: {\n\t\t\t\t\tshowBcs: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!res || res.error || !res.data) {\n\t\t\t\tthrow new InvalidGetObjectError(`KeyServer ${objectId} not found; ${res.error}`);\n\t\t\t}\n\n\t\t\tif (!res.data.bcs || !('bcsBytes' in res.data.bcs)) {\n\t\t\t\tthrow new InvalidGetObjectError(\n\t\t\t\t\t`Invalid KeyServer query: ${objectId}, expected object, got package`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet ks = KeyServerMove.parse(fromBase64(res.data.bcs!.bcsBytes));\n\t\t\tif (ks.keyType !== 0) {\n\t\t\t\tthrow new UnsupportedFeatureError(`Unsupported key type ${ks.keyType}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tobjectId,\n\t\t\t\tname: ks.name,\n\t\t\t\turl: ks.url,\n\t\t\t\tkeyType: KeyServerType.BonehFranklinBLS12381,\n\t\t\t\tpk: new Uint8Array(ks.pk),\n\t\t\t};\n\t\t}),\n\t);\n}\n\n/**\n * Given a KeyServer, fetch the proof of possession (PoP) from the URL and verify it\n * against the pubkey. This should be used only rarely when the dapp uses a dynamic\n * set of key servers.\n *\n * @param server - The KeyServer to verify.\n * @returns - True if the key server is valid, false otherwise.\n */\nexport async function verifyKeyServer(server: KeyServer, timeout: number): Promise<boolean> {\n\tconst requestId = crypto.randomUUID();\n\tconst response = await fetch(server.url! + '/v1/service', {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Request-Id': requestId,\n\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t},\n\t\tsignal: AbortSignal.timeout(timeout),\n\t});\n\n\tawait SealAPIError.assertResponse(response, requestId);\n\tconst serviceResponse = await response.json();\n\n\tif (serviceResponse.service_id !== server.objectId) {\n\t\treturn false;\n\t}\n\tconst fullMsg = new Uint8Array([...DST_POP, ...server.pk, ...fromHex(server.objectId)]);\n\treturn bls12_381.verifyShortSignature(fromBase64(serviceResponse.pop), fullMsg, server.pk);\n}\n", "export function getRandomBytes(numBytes: number): Uint8Array {\r\n  return crypto.getRandomValues(new Uint8Array(numBytes));\r\n}\r\n", "import {getRandomBytes} from 'shamir-secret-sharing/csprng';\r\n\r\n// The Polynomial used is: x⁸ + x⁴ + x³ + x + 1\r\n//\r\n// Lookup tables pulled from:\r\n//\r\n//     * https://github.com/hashicorp/vault/blob/9d46671659cbfe7bbd3e78d1073dfb22936a4437/shamir/tables.go\r\n//     * http://www.samiam.org/galois.html\r\n//\r\n// 0xe5 (229) is used as the generator.\r\n\r\n// Provides log(X)/log(g) at each index X.\r\nconst LOG_TABLE: Readonly<Uint8Array> = new Uint8Array([\r\n  0x00, 0xff, 0xc8, 0x08, 0x91, 0x10, 0xd0, 0x36, 0x5a, 0x3e, 0xd8, 0x43, 0x99, 0x77, 0xfe, 0x18,\r\n  0x23, 0x20, 0x07, 0x70, 0xa1, 0x6c, 0x0c, 0x7f, 0x62, 0x8b, 0x40, 0x46, 0xc7, 0x4b, 0xe0, 0x0e,\r\n  0xeb, 0x16, 0xe8, 0xad, 0xcf, 0xcd, 0x39, 0x53, 0x6a, 0x27, 0x35, 0x93, 0xd4, 0x4e, 0x48, 0xc3,\r\n  0x2b, 0x79, 0x54, 0x28, 0x09, 0x78, 0x0f, 0x21, 0x90, 0x87, 0x14, 0x2a, 0xa9, 0x9c, 0xd6, 0x74,\r\n  0xb4, 0x7c, 0xde, 0xed, 0xb1, 0x86, 0x76, 0xa4, 0x98, 0xe2, 0x96, 0x8f, 0x02, 0x32, 0x1c, 0xc1,\r\n  0x33, 0xee, 0xef, 0x81, 0xfd, 0x30, 0x5c, 0x13, 0x9d, 0x29, 0x17, 0xc4, 0x11, 0x44, 0x8c, 0x80,\r\n  0xf3, 0x73, 0x42, 0x1e, 0x1d, 0xb5, 0xf0, 0x12, 0xd1, 0x5b, 0x41, 0xa2, 0xd7, 0x2c, 0xe9, 0xd5,\r\n  0x59, 0xcb, 0x50, 0xa8, 0xdc, 0xfc, 0xf2, 0x56, 0x72, 0xa6, 0x65, 0x2f, 0x9f, 0x9b, 0x3d, 0xba,\r\n  0x7d, 0xc2, 0x45, 0x82, 0xa7, 0x57, 0xb6, 0xa3, 0x7a, 0x75, 0x4f, 0xae, 0x3f, 0x37, 0x6d, 0x47,\r\n  0x61, 0xbe, 0xab, 0xd3, 0x5f, 0xb0, 0x58, 0xaf, 0xca, 0x5e, 0xfa, 0x85, 0xe4, 0x4d, 0x8a, 0x05,\r\n  0xfb, 0x60, 0xb7, 0x7b, 0xb8, 0x26, 0x4a, 0x67, 0xc6, 0x1a, 0xf8, 0x69, 0x25, 0xb3, 0xdb, 0xbd,\r\n  0x66, 0xdd, 0xf1, 0xd2, 0xdf, 0x03, 0x8d, 0x34, 0xd9, 0x92, 0x0d, 0x63, 0x55, 0xaa, 0x49, 0xec,\r\n  0xbc, 0x95, 0x3c, 0x84, 0x0b, 0xf5, 0xe6, 0xe7, 0xe5, 0xac, 0x7e, 0x6e, 0xb9, 0xf9, 0xda, 0x8e,\r\n  0x9a, 0xc9, 0x24, 0xe1, 0x0a, 0x15, 0x6b, 0x3a, 0xa0, 0x51, 0xf4, 0xea, 0xb2, 0x97, 0x9e, 0x5d,\r\n  0x22, 0x88, 0x94, 0xce, 0x19, 0x01, 0x71, 0x4c, 0xa5, 0xe3, 0xc5, 0x31, 0xbb, 0xcc, 0x1f, 0x2d,\r\n  0x3b, 0x52, 0x6f, 0xf6, 0x2e, 0x89, 0xf7, 0xc0, 0x68, 0x1b, 0x64, 0x04, 0x06, 0xbf, 0x83, 0x38,\r\n]);\r\n\r\n// Provides the exponentiation value at each index X.\r\nconst EXP_TABLE: Readonly<Uint8Array> = new Uint8Array([\r\n  0x01, 0xe5, 0x4c, 0xb5, 0xfb, 0x9f, 0xfc, 0x12, 0x03, 0x34, 0xd4, 0xc4, 0x16, 0xba, 0x1f, 0x36,\r\n  0x05, 0x5c, 0x67, 0x57, 0x3a, 0xd5, 0x21, 0x5a, 0x0f, 0xe4, 0xa9, 0xf9, 0x4e, 0x64, 0x63, 0xee,\r\n  0x11, 0x37, 0xe0, 0x10, 0xd2, 0xac, 0xa5, 0x29, 0x33, 0x59, 0x3b, 0x30, 0x6d, 0xef, 0xf4, 0x7b,\r\n  0x55, 0xeb, 0x4d, 0x50, 0xb7, 0x2a, 0x07, 0x8d, 0xff, 0x26, 0xd7, 0xf0, 0xc2, 0x7e, 0x09, 0x8c,\r\n  0x1a, 0x6a, 0x62, 0x0b, 0x5d, 0x82, 0x1b, 0x8f, 0x2e, 0xbe, 0xa6, 0x1d, 0xe7, 0x9d, 0x2d, 0x8a,\r\n  0x72, 0xd9, 0xf1, 0x27, 0x32, 0xbc, 0x77, 0x85, 0x96, 0x70, 0x08, 0x69, 0x56, 0xdf, 0x99, 0x94,\r\n  0xa1, 0x90, 0x18, 0xbb, 0xfa, 0x7a, 0xb0, 0xa7, 0xf8, 0xab, 0x28, 0xd6, 0x15, 0x8e, 0xcb, 0xf2,\r\n  0x13, 0xe6, 0x78, 0x61, 0x3f, 0x89, 0x46, 0x0d, 0x35, 0x31, 0x88, 0xa3, 0x41, 0x80, 0xca, 0x17,\r\n  0x5f, 0x53, 0x83, 0xfe, 0xc3, 0x9b, 0x45, 0x39, 0xe1, 0xf5, 0x9e, 0x19, 0x5e, 0xb6, 0xcf, 0x4b,\r\n  0x38, 0x04, 0xb9, 0x2b, 0xe2, 0xc1, 0x4a, 0xdd, 0x48, 0x0c, 0xd0, 0x7d, 0x3d, 0x58, 0xde, 0x7c,\r\n  0xd8, 0x14, 0x6b, 0x87, 0x47, 0xe8, 0x79, 0x84, 0x73, 0x3c, 0xbd, 0x92, 0xc9, 0x23, 0x8b, 0x97,\r\n  0x95, 0x44, 0xdc, 0xad, 0x40, 0x65, 0x86, 0xa2, 0xa4, 0xcc, 0x7f, 0xec, 0xc0, 0xaf, 0x91, 0xfd,\r\n  0xf7, 0x4f, 0x81, 0x2f, 0x5b, 0xea, 0xa8, 0x1c, 0x02, 0xd1, 0x98, 0x71, 0xed, 0x25, 0xe3, 0x24,\r\n  0x06, 0x68, 0xb3, 0x93, 0x2c, 0x6f, 0x3e, 0x6c, 0x0a, 0xb8, 0xce, 0xae, 0x74, 0xb1, 0x42, 0xb4,\r\n  0x1e, 0xd3, 0x49, 0xe9, 0x9c, 0xc8, 0xc6, 0xc7, 0x22, 0x6e, 0xdb, 0x20, 0xbf, 0x43, 0x51, 0x52,\r\n  0x66, 0xb2, 0x76, 0x60, 0xda, 0xc5, 0xf3, 0xf6, 0xaa, 0xcd, 0x9a, 0xa0, 0x75, 0x54, 0x0e, 0x01,\r\n]);\r\n\r\n// Combines two numbers in GF(2^8).\r\n// This can be used for both addition and subtraction.\r\nfunction add(a: number, b: number): number {\r\n  if (!Number.isInteger(a) || a < 0 || a > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  if (!Number.isInteger(b) || b < 0 || b > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  return a ^ b;\r\n}\r\n\r\n// Divides two numbers in GF(2^8).\r\nfunction div(a: number, b: number): number {\r\n  if (!Number.isInteger(a) || a < 0 || a > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  if (!Number.isInteger(b) || b < 0 || b > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  // This should never happen\r\n  if (b === 0) {\r\n    throw new Error('cannot divide by zero');\r\n  }\r\n\r\n  const logA = LOG_TABLE[a]!;\r\n  const logB = LOG_TABLE[b]!;\r\n  const diff = (logA - logB + 255) % 255;\r\n  const result = EXP_TABLE[diff]!;\r\n\r\n  return a === 0 ? 0 : result;\r\n}\r\n\r\n// Multiplies two numbers in GF(2^8).\r\nfunction mult(a: number, b: number): number {\r\n  if (!Number.isInteger(a) || a < 0 || a > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  if (!Number.isInteger(b) || b < 0 || b > 255) {\r\n    throw new RangeError('Number is out of Uint8 range');\r\n  }\r\n  const logA = LOG_TABLE[a]!;\r\n  const logB = LOG_TABLE[b]!;\r\n  const sum = (logA + logB) % 255;\r\n  const result = EXP_TABLE[sum]!;\r\n\r\n  return a === 0 || b === 0 ? 0 : result;\r\n}\r\n\r\n// Takes N sample points and returns the value at a given x using a lagrange interpolation.\r\nfunction interpolatePolynomial(xSamples: Uint8Array, ySamples: Uint8Array, x: number): number {\r\n  if (xSamples.length !== ySamples.length) {\r\n    throw new Error('sample length mistmatch');\r\n  }\r\n\r\n  const limit = xSamples.length;\r\n\r\n  let basis = 0;\r\n  let result = 0;\r\n\r\n  for (let i = 0; i < limit; i++) {\r\n    basis = 1;\r\n\r\n    for (let j = 0; j < limit; ++j) {\r\n      if (i === j) {\r\n        continue;\r\n      }\r\n      const num = add(x, xSamples[j]!);\r\n      const denom = add(xSamples[i]!, xSamples[j]!);\r\n      const term = div(num, denom);\r\n      basis = mult(basis, term);\r\n    }\r\n\r\n    result = add(result, mult(ySamples[i]!, basis));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Evaluates a polynomial with the given x using Horner's method.\r\nfunction evaluate(coefficients: Uint8Array, x: number, degree: number) {\r\n  if (x === 0) {\r\n    throw new Error('cannot evaluate secret polynomial at zero');\r\n  }\r\n\r\n  let result = coefficients[degree]!;\r\n\r\n  for (let i = degree - 1; i >= 0; i--) {\r\n    const coefficient = coefficients[i]!;\r\n    result = add(mult(result, x), coefficient);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction getRandomByte(): number {\r\n  return getRandomBytes(1)[0]!;\r\n}\r\n\r\nfunction getNonZeroRandomByte(): number {\r\n  while (true) {\r\n    const byte = getRandomByte();\r\n    if (byte > 0) {\r\n      return byte;\r\n    }\r\n  }\r\n}\r\n\r\n// Creates a pseudo-random set of coefficients for a polynomial.\r\nfunction newCoefficients(intercept: number, degree: number): Readonly<Uint8Array> {\r\n  const coefficients = new Uint8Array(degree + 1);\r\n\r\n  // The first byte is always the intercept\r\n  coefficients[0] = intercept;\r\n\r\n  for (let i = 1; i <= degree; i++) {\r\n    // degree is equal to t-1, where t is the threshold of required shares.\r\n    // The coefficient at t-1 cannot equal 0.\r\n    const coefficientTMinus1 = i === degree;\r\n    coefficients[i] = coefficientTMinus1 ? getNonZeroRandomByte() : getRandomByte();\r\n  }\r\n\r\n  return coefficients;\r\n}\r\n\r\n// Creates a set of values from [1, 256).\r\n// Returns a psuedo-random shuffling of the set.\r\nfunction newCoordinates(): Readonly<Uint8Array> {\r\n  const coordinates = new Uint8Array(255);\r\n  for (let i = 0; i < 255; i++) {\r\n    coordinates[i] = i + 1;\r\n  }\r\n\r\n  // Pseudo-randomize the array of coordinates.\r\n  //\r\n  // This impl maps almost perfectly because both of the lists (coordinates and randomIndices)\r\n  // have a length of 255 and byte values are between 0 and 255 inclusive. The only value that\r\n  // does not map neatly here is if the random byte is 255, since that value used as an index\r\n  // would be out of bounds. Thus, for bytes whose value is 255, wrap around to 0.\r\n  const randomIndices = getRandomBytes(255);\r\n  for (let i = 0; i < 255; i++) {\r\n    const j = randomIndices[i]! % 255; // Make sure to handle the case where the byte is 255.\r\n    const temp = coordinates[i]!;\r\n    coordinates[i] = coordinates[j]!;\r\n    coordinates[j] = temp;\r\n  }\r\n\r\n  return coordinates;\r\n}\r\n\r\n// Helpers for declarative argument validation.\r\nconst AssertArgument = {\r\n  instanceOf(object: any, constructor: Function, message: string) {\r\n    if (object.constructor !== constructor) {\r\n      throw new TypeError(message);\r\n    }\r\n  },\r\n\r\n  inRange(n: number, start: number, until: number, message: string) {\r\n    if (!(start < until && n >= start && n < until)) {\r\n      throw new RangeError(message);\r\n    }\r\n  },\r\n\r\n  greaterThanOrEqualTo(a: number, b: number, message: string) {\r\n    if (a < b) {\r\n      throw new Error(message);\r\n    }\r\n  },\r\n\r\n  equalTo(a: any, b: any, message: string) {\r\n    if (a !== b) {\r\n      throw new Error(message);\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Splits a `secret` into `shares` number of shares, requiring `threshold` of them to reconstruct `secret`.\r\n *\r\n * @param secret The secret value to split into shares.\r\n * @param shares The total number of shares to split `secret` into. Must be at least 2 and at most 255.\r\n * @param threshold The minimum number of shares required to reconstruct `secret`. Must be at least 2 and at most 255.\r\n * @returns A list of `shares` shares.\r\n */\r\nexport async function split(\r\n  secret: Uint8Array,\r\n  shares: number,\r\n  threshold: number,\r\n): Promise<Uint8Array[]> {\r\n  // secret must be a non-empty Uint8Array\r\n  AssertArgument.instanceOf(secret, Uint8Array, 'secret must be a Uint8Array');\r\n  AssertArgument.greaterThanOrEqualTo(secret.byteLength, 1, 'secret cannot be empty');\r\n\r\n  // shares must be a number in the range [2, 256)\r\n  AssertArgument.instanceOf(shares, Number, 'shares must be a number');\r\n  AssertArgument.inRange(shares, 2, 256, 'shares must be at least 2 and at most 255');\r\n\r\n  // threshold must be a number in the range [2, 256)\r\n  AssertArgument.instanceOf(threshold, Number, 'threshold must be a number');\r\n  AssertArgument.inRange(threshold, 2, 256, 'threshold must be at least 2 and at most 255');\r\n\r\n  // total number of shares must be greater than or equal to the required threshold\r\n  AssertArgument.greaterThanOrEqualTo(shares, threshold, 'shares cannot be less than threshold');\r\n\r\n  const result: Uint8Array[] = [];\r\n  const secretLength = secret.byteLength;\r\n  const xCoordinates = newCoordinates();\r\n\r\n  for (let i = 0; i < shares; i++) {\r\n    const share = new Uint8Array(secretLength + 1);\r\n    share[secretLength] = xCoordinates[i]!;\r\n    result.push(share);\r\n  }\r\n\r\n  const degree = threshold - 1;\r\n\r\n  for (let i = 0; i < secretLength; i++) {\r\n    const byte = secret[i]!;\r\n    const coefficients = newCoefficients(byte, degree);\r\n\r\n    for (let j = 0; j < shares; ++j) {\r\n      const x = xCoordinates[j]!;\r\n      const y = evaluate(coefficients, x, degree);\r\n      result[j]![i] = y;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Combines `shares` to reconstruct the secret.\r\n *\r\n * @param shares A list of shares to reconstruct the secret from. Must be at least 2 and at most 255.\r\n * @returns The reconstructed secret.\r\n */\r\nexport async function combine(shares: Uint8Array[]): Promise<Uint8Array> {\r\n  // Shares must be an array with length in the range [2, 256)\r\n  AssertArgument.instanceOf(shares, Array, 'shares must be an Array');\r\n  AssertArgument.inRange(\r\n    shares.length,\r\n    2,\r\n    256,\r\n    'shares must have at least 2 and at most 255 elements',\r\n  );\r\n\r\n  // Shares must be a Uint8Array with at least 2 bytes and all shares must have the same byte length.\r\n  const share1 = shares[0]!;\r\n  AssertArgument.instanceOf(share1, Uint8Array, 'each share must be a Uint8Array');\r\n  for (const share of shares) {\r\n    AssertArgument.instanceOf(share, Uint8Array, 'each share must be a Uint8Array');\r\n    AssertArgument.greaterThanOrEqualTo(share.byteLength, 2, 'each share must be at least 2 bytes');\r\n    AssertArgument.equalTo(\r\n      share.byteLength,\r\n      share1.byteLength,\r\n      'all shares must have the same byte length',\r\n    );\r\n  }\r\n\r\n  const sharesLength = shares.length;\r\n  const shareLength = share1.byteLength;\r\n\r\n  // This will be our reconstructed secret\r\n  const secretLength = shareLength - 1;\r\n  const secret = new Uint8Array(secretLength);\r\n\r\n  const xSamples = new Uint8Array(sharesLength);\r\n  const ySamples = new Uint8Array(sharesLength);\r\n\r\n  const samples: Set<number> = new Set();\r\n  for (let i = 0; i < sharesLength; i++) {\r\n    const share = shares[i]!;\r\n    const sample = share[shareLength - 1]!;\r\n\r\n    // The last byte of each share should be a unique value between 1-255 inclusive.\r\n    if (samples.has(sample)) {\r\n      throw new Error('shares must contain unique values but a duplicate was found');\r\n    }\r\n\r\n    samples.add(sample);\r\n    xSamples[i] = sample;\r\n  }\r\n\r\n  // Reconstruct each byte\r\n  for (let i = 0; i < secretLength; i++) {\r\n    // Set the y value for each sample\r\n    for (let j = 0; j < sharesLength; ++j) {\r\n      ySamples[j] = shares[j]![i]!;\r\n    }\r\n\r\n    // Interpolate the polynomial and compute the value at 0\r\n    secret[i] = interpolatePolynomial(xSamples, ySamples, 0);\r\n  }\r\n\r\n  return secret;\r\n}\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport { equalBytes } from '@noble/curves/abstract/utils';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nimport type { Ciphertext } from './bcs.js';\nimport { InvalidCiphertextError } from './error.js';\nimport { xorUnchecked } from './utils.js';\n\n// Use a fixed IV for AES.\nexport const iv = Uint8Array.from([\n\t138, 55, 153, 253, 198, 46, 121, 219, 160, 128, 89, 7, 214, 156, 148, 220,\n]);\n\nasync function generateAesKey(): Promise<Uint8Array> {\n\tconst key = await crypto.subtle.generateKey(\n\t\t{\n\t\t\tname: 'AES-GCM',\n\t\t\tlength: 256,\n\t\t},\n\t\ttrue,\n\t\t['encrypt', 'decrypt'],\n\t);\n\treturn await crypto.subtle.exportKey('raw', key).then((keyData) => new Uint8Array(keyData));\n}\n\nexport interface EncryptionInput {\n\tencrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;\n\tgenerateKey(): Promise<Uint8Array>;\n}\n\nexport class AesGcm256 implements EncryptionInput {\n\treadonly plaintext: Uint8Array;\n\treadonly aad: Uint8Array;\n\n\tconstructor(msg: Uint8Array, aad: Uint8Array) {\n\t\tthis.plaintext = msg;\n\t\tthis.aad = aad;\n\t}\n\n\tgenerateKey(): Promise<Uint8Array> {\n\t\treturn generateAesKey();\n\t}\n\n\tasync encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput> {\n\t\tconst aesCryptoKey = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt']);\n\n\t\tconst blob = new Uint8Array(\n\t\t\tawait crypto.subtle.encrypt(\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tiv,\n\t\t\t\t\tadditionalData: this.aad,\n\t\t\t\t},\n\t\t\t\taesCryptoKey,\n\t\t\t\tthis.plaintext,\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tAes256Gcm: {\n\t\t\t\tblob,\n\t\t\t\taad: this.aad ?? [],\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async decrypt(\n\t\tkey: Uint8Array,\n\t\tciphertext: typeof Ciphertext.$inferInput,\n\t): Promise<Uint8Array> {\n\t\tif (!('Aes256Gcm' in ciphertext)) {\n\t\t\tthrow new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);\n\t\t}\n\n\t\tconst aesCryptoKey = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt']);\n\n\t\treturn new Uint8Array(\n\t\t\tawait crypto.subtle.decrypt(\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tiv,\n\t\t\t\t\tadditionalData: new Uint8Array(ciphertext.Aes256Gcm.aad ?? []),\n\t\t\t\t},\n\t\t\t\taesCryptoKey,\n\t\t\t\tnew Uint8Array(ciphertext.Aes256Gcm.blob),\n\t\t\t),\n\t\t);\n\t}\n}\n\nexport class Plain implements EncryptionInput {\n\tasync encrypt(_key: Uint8Array): Promise<typeof Ciphertext.$inferInput> {\n\t\treturn {\n\t\t\tPlain: {},\n\t\t};\n\t}\n\n\tgenerateKey(): Promise<Uint8Array> {\n\t\treturn generateAesKey();\n\t}\n}\n\n/**\n * Authenticated encryption using CTR mode with HMAC-SHA3-256 as a PRF.\n * 1. Derive an encryption key, <i>k<sub>1</sub> = <b>hmac</b>(key, 1)</i>.\n * 2. Chunk the message into blocks of 32 bytes, <i>m = m<sub>1</sub> || ... || m<sub>n</sub></i>.\n * 3. Let the ciphertext be defined by <i>c = c<sub>1</sub> || ... || c<sub>n</sub></i> where <i>c<sub>i</sub> = m<sub>i</sub> \u2295 <b>hmac</b>(k<sub>1</sub>, i)</i>.\n * 4. Compute a MAC over the AAD and the ciphertext, <i>mac = <b>hmac</b>(k<sub>2</sub>, aad || c) where k<sub>2</sub> = <b>hmac</b>(key, 2)</i>.\n * 5. Return <i>mac || c</i>.\n */\nexport class Hmac256Ctr implements EncryptionInput {\n\treadonly plaintext: Uint8Array;\n\treadonly aad: Uint8Array;\n\n\tconstructor(msg: Uint8Array, aad: Uint8Array) {\n\t\tthis.plaintext = msg;\n\t\tthis.aad = aad;\n\t}\n\n\tgenerateKey(): Promise<Uint8Array> {\n\t\treturn generateAesKey();\n\t}\n\n\tasync encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput> {\n\t\tconst blob = Hmac256Ctr.encryptInCtrMode(key, this.plaintext);\n\t\tconst mac = Hmac256Ctr.computeMac(key, this.aad, blob);\n\t\treturn {\n\t\t\tHmac256Ctr: {\n\t\t\t\tblob,\n\t\t\t\tmac,\n\t\t\t\taad: this.aad ?? [],\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async decrypt(\n\t\tkey: Uint8Array,\n\t\tciphertext: typeof Ciphertext.$inferInput,\n\t): Promise<Uint8Array> {\n\t\tif (!('Hmac256Ctr' in ciphertext)) {\n\t\t\tthrow new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);\n\t\t}\n\t\tconst aad = new Uint8Array(ciphertext.Hmac256Ctr.aad ?? []);\n\t\tconst blob = new Uint8Array(ciphertext.Hmac256Ctr.blob);\n\t\tconst mac = Hmac256Ctr.computeMac(key, aad, blob);\n\t\tif (!equalBytes(mac, new Uint8Array(ciphertext.Hmac256Ctr.mac))) {\n\t\t\tthrow new InvalidCiphertextError(`Invalid MAC ${mac}`);\n\t\t}\n\t\treturn Hmac256Ctr.encryptInCtrMode(key, blob);\n\t}\n\n\tprivate static computeMac(key: Uint8Array, aad: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n\t\tconst macKey = hmac(sha3_256, key, MacKeyTag);\n\t\tconst macInput = new Uint8Array([...toBytes(aad.length), ...aad, ...ciphertext]);\n\t\tconst mac = hmac(sha3_256, macKey, macInput);\n\t\treturn mac;\n\t}\n\n\tprivate static encryptInCtrMode(key: Uint8Array, msg: Uint8Array): Uint8Array {\n\t\tconst blockSize = 32;\n\t\tlet result = Uint8Array.from({ length: msg.length }, () => 0);\n\t\tconst encryptionKey = hmac(sha3_256, key, EncryptionKeyTag);\n\t\tfor (let i = 0; i * blockSize < msg.length; i++) {\n\t\t\tconst block = msg.slice(i * blockSize, (i + 1) * blockSize);\n\t\t\tlet mask = hmac(sha3_256, encryptionKey, toBytes(i));\n\t\t\tconst encryptedBlock = xorUnchecked(block, mask);\n\t\t\tresult.set(encryptedBlock, i * blockSize);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Convert a u64 to bytes using little-endian representation.\n */\nfunction toBytes(n: number): Uint8Array {\n\treturn bcs.u64().serialize(n).toBytes();\n}\n\nconst EncryptionKeyTag = new Uint8Array([1]);\nconst MacKeyTag = new Uint8Array([2]);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\nimport { combine as externalCombine } from 'shamir-secret-sharing';\n\nimport type { EncryptedObject } from './bcs.js';\nimport type { G1Element } from './bls12381.js';\nimport { G2Element } from './bls12381.js';\nimport { AesGcm256, Hmac256Ctr } from './dem.js';\nimport { InvalidCiphertextError, UnsupportedFeatureError } from './error.js';\nimport { BonehFranklinBLS12381Services, DST } from './ibe.js';\nimport { deriveKey, KeyPurpose } from './kdf.js';\nimport type { KeyCacheKey } from './types.js';\nimport { createFullId } from './utils.js';\n\nexport interface DecryptOptions {\n\tencryptedObject: typeof EncryptedObject.$inferType;\n\tkeys: Map<KeyCacheKey, G1Element>;\n}\n\n/**\n * Decrypt the given encrypted bytes with the given cached secret keys for the full ID.\n * It's assumed that fetchKeys has been called to fetch the secret keys for enough key servers\n * otherwise, this will throw an error.\n *\n * @returns - The decrypted plaintext corresponding to ciphertext.\n */\nexport async function decrypt({ encryptedObject, keys }: DecryptOptions): Promise<Uint8Array> {\n\tif (!encryptedObject.encryptedShares.BonehFranklinBLS12381) {\n\t\tthrow new UnsupportedFeatureError('Encryption mode not supported');\n\t}\n\n\tconst fullId = createFullId(DST, encryptedObject.packageId, encryptedObject.id);\n\n\t// Get the indices of the service whose keys are in the keystore.\n\tconst inKeystore = encryptedObject.services\n\t\t.map((_, i) => i)\n\t\t.filter((i) => keys.has(`${fullId}:${encryptedObject.services[i][0]}`));\n\n\tif (inKeystore.length < encryptedObject.threshold) {\n\t\tthrow new Error('Not enough shares. Please fetch more keys.');\n\t}\n\n\tconst encryptedShares = encryptedObject.encryptedShares.BonehFranklinBLS12381.encryptedShares;\n\tif (encryptedShares.length !== encryptedObject.services.length) {\n\t\tthrow new InvalidCiphertextError(\n\t\t\t`Mismatched shares ${encryptedShares.length} and services ${encryptedObject.services.length}`,\n\t\t);\n\t}\n\n\tconst nonce = G2Element.fromBytes(encryptedObject.encryptedShares.BonehFranklinBLS12381.nonce);\n\n\t// Decrypt each share.\n\tconst shares = inKeystore.map((i: number) => {\n\t\tconst [objectId, index] = encryptedObject.services[i];\n\t\t// Use the index as the unique info parameter to allow for multiple shares per key server.\n\t\tconst share = BonehFranklinBLS12381Services.decrypt(\n\t\t\tnonce,\n\t\t\tkeys.get(`${fullId}:${objectId}`)!,\n\t\t\tencryptedShares[i],\n\t\t\tfromHex(fullId),\n\t\t\t[objectId, index],\n\t\t);\n\t\t// The Shamir secret sharing library expects the index/x-coordinate to be at the end of the share.\n\t\treturn { index, share };\n\t});\n\n\t// Combine the decrypted shares into the key.\n\tconst key = await combine(shares);\n\tconst demKey = deriveKey(KeyPurpose.DEM, key);\n\tif (encryptedObject.ciphertext.Aes256Gcm) {\n\t\ttry {\n\t\t\t// Decrypt the ciphertext with the key.\n\t\t\treturn AesGcm256.decrypt(demKey, encryptedObject.ciphertext);\n\t\t} catch {\n\t\t\tthrow new Error('Decryption failed');\n\t\t}\n\t} else if (encryptedObject.ciphertext.Plain) {\n\t\t// In case `Plain` mode is used, return the key.\n\t\treturn demKey;\n\t} else if (encryptedObject.ciphertext.Hmac256Ctr) {\n\t\ttry {\n\t\t\treturn Hmac256Ctr.decrypt(demKey, encryptedObject.ciphertext);\n\t\t} catch {\n\t\t\tthrow new Error('Decryption failed');\n\t\t}\n\t} else {\n\t\tthrow new Error('Invalid encrypted object');\n\t}\n}\n\n/**\n * Helper function that combines the shares into the key.\n * @param shares - The shares to combine.\n * @returns - The combined key.\n */\nasync function combine(shares: { index: number; share: Uint8Array }[]): Promise<Uint8Array> {\n\tif (shares.length === 0) {\n\t\tthrow new Error('Invalid shares length');\n\t} else if (shares.length === 1) {\n\t\t// The Shamir secret sharing library expects at least two shares.\n\t\t// If there is only one and the threshold is 1, the reconstructed secret is the same as the share.\n\t\treturn Promise.resolve(shares[0].share);\n\t}\n\n\t// The Shamir secret sharing library expects the index/x-coordinate to be at the end of the share\n\treturn externalCombine(\n\t\tshares.map(({ index, share }) => {\n\t\t\tconst packedShare = new Uint8Array(share.length + 1);\n\t\t\tpackedShare.set(share, 0);\n\t\t\tpackedShare[share.length] = index;\n\t\t\treturn packedShare;\n\t\t}),\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromHex } from '@mysten/bcs';\nimport { isValidSuiObjectId } from '@mysten/sui/utils';\nimport { split as externalSplit } from 'shamir-secret-sharing';\n\nimport type { IBEEncryptions } from './bcs.js';\nimport { EncryptedObject } from './bcs.js';\nimport type { EncryptionInput } from './dem.js';\nimport { UserError } from './error.js';\nimport { BonehFranklinBLS12381Services, DST } from './ibe.js';\nimport { deriveKey, KeyPurpose } from './kdf.js';\nimport type { KeyServer } from './key-server.js';\nimport { createFullId } from './utils.js';\n\nexport const MAX_U8 = 255;\n\n/**\n * Given full ID and what key servers to use, return the encrypted message under the identity and return the bcs bytes of the encrypted object.\n *\n * @param keyServers - A list of KeyServers (same server can be used multiple times)\n * @param kemType - The type of KEM to use.\n * @param packageId - packageId\n * @param id - id\n * @param encryptionInput - Input to the encryption. Should be one of the EncryptionInput types, AesGcmEncryptionInput or Plain.\n * @param threshold - The threshold for the TSS encryption.\n * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.\n * Since the key can be used to decrypt, it should not be shared but can be used eg. for backup.\n */\nexport async function encrypt({\n\tkeyServers,\n\tkemType,\n\tthreshold,\n\tpackageId,\n\tid,\n\tencryptionInput,\n}: {\n\tkeyServers: KeyServer[];\n\tkemType: KemType;\n\tthreshold: number;\n\tpackageId: string;\n\tid: string;\n\tencryptionInput: EncryptionInput;\n}): Promise<{\n\tencryptedObject: Uint8Array;\n\tkey: Uint8Array;\n}> {\n\t// Check inputs\n\tif (\n\t\tkeyServers.length < threshold ||\n\t\tthreshold === 0 ||\n\t\tkeyServers.length > MAX_U8 ||\n\t\tthreshold > MAX_U8 ||\n\t\t!isValidSuiObjectId(packageId)\n\t) {\n\t\tthrow new UserError(\n\t\t\t`Invalid key servers or threshold ${threshold} for ${keyServers.length} key servers for package ${packageId}`,\n\t\t);\n\t}\n\n\t// Generate a random symmetric key and encrypt the encryption input using this key.\n\tconst key = await encryptionInput.generateKey();\n\tconst demKey = deriveKey(KeyPurpose.DEM, key);\n\tconst ciphertext = await encryptionInput.encrypt(demKey);\n\n\t// Split the symmetric key into shares and encrypt each share with the public keys of the key servers.\n\tconst shares = await split(key, keyServers.length, threshold);\n\n\t// Encrypt the shares with the public keys of the key servers.\n\tconst fullId = createFullId(DST, packageId, id);\n\tconst encryptedShares = encryptBatched(\n\t\tkeyServers,\n\t\tkemType,\n\t\tfromHex(fullId),\n\t\tshares.map(({ share, index }) => ({\n\t\t\tmsg: share,\n\t\t\tindex,\n\t\t})),\n\t\tderiveKey(KeyPurpose.EncryptedRandomness, key),\n\t);\n\n\t// Services and indices of their shares are stored as a tuple\n\tconst services: [string, number][] = keyServers.map((server, i) => [\n\t\tserver.objectId,\n\t\tshares[i].index,\n\t]);\n\n\treturn {\n\t\tencryptedObject: EncryptedObject.serialize({\n\t\t\tversion: 0,\n\t\t\tpackageId,\n\t\t\tid,\n\t\t\tservices,\n\t\t\tthreshold,\n\t\t\tencryptedShares,\n\t\t\tciphertext,\n\t\t}).toBytes(),\n\t\tkey: demKey,\n\t};\n}\n\nexport enum KemType {\n\tBonehFranklinBLS12381DemCCA = 0,\n}\n\nexport enum DemType {\n\tAesGcm256 = 0,\n\tHmac256Ctr = 1,\n}\n\nfunction encryptBatched(\n\tkeyServers: KeyServer[],\n\tkemType: KemType,\n\tid: Uint8Array,\n\tshares: { msg: Uint8Array; index: number }[],\n\trandomnessKey: Uint8Array,\n): typeof IBEEncryptions.$inferType {\n\tswitch (kemType) {\n\t\tcase KemType.BonehFranklinBLS12381DemCCA:\n\t\t\treturn new BonehFranklinBLS12381Services(keyServers).encryptBatched(\n\t\t\t\tid,\n\t\t\t\tshares,\n\t\t\t\trandomnessKey,\n\t\t\t);\n\t}\n}\n\nasync function split(\n\tsecret: Uint8Array,\n\tn: number,\n\tthreshold: number,\n): Promise<{ index: number; share: Uint8Array }[]> {\n\t// The externalSplit function is from the 'shamir-secret-sharing' package and requires t > 1 and n >= 2.\n\t// So we handle the special cases here.\n\tif (n === 0 || threshold === 0 || threshold > n) {\n\t\tthrow new Error('Invalid threshold or number of shares');\n\t} else if (threshold === 1) {\n\t\t// If the threshold is 1, the secret is not split.\n\t\tconst result = [];\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\t// The shared polynomial is a constant in this case, so the index doesn't matter.\n\t\t\t// To make sure they are unique, we use a counter.\n\t\t\tresult.push({ share: secret, index: i });\n\t\t}\n\t\treturn Promise.resolve(result);\n\t}\n\n\treturn externalSplit(secret, n, threshold).then((share) =>\n\t\tshare.map((s) => ({\n\t\t\tshare: s.subarray(0, s.length - 1),\n\t\t\t// split() returns the share index in the last byte\n\t\t\tindex: s[s.length - 1],\n\t\t})),\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { G1Element, G2Element, Scalar } from './bls12381.js';\n\n/**\n * Decrypt a ciphertext with a given secret key. The secret key must be a 32-byte scalar.\n * The ciphertext is a pair of G1Elements (48 bytes).\n */\nexport function elgamalDecrypt(sk: Uint8Array, ciphertext: [Uint8Array, Uint8Array]): Uint8Array {\n\treturn decrypt(Scalar.fromBytes(sk), [\n\t\tG1Element.fromBytes(ciphertext[0]),\n\t\tG1Element.fromBytes(ciphertext[1]),\n\t]).toBytes();\n}\n\n/**\n * Decrypt a ciphertext with a given secret key. The secret key must be a 32-byte scalar.\n * The ciphertext is a pair of G1Elements (48 bytes).\n */\nfunction decrypt(sk: Scalar, encryption: [G1Element, G1Element]): G1Element {\n\treturn encryption[1].subtract(encryption[0].multiply(sk));\n}\n\n/** Generate a random secret key. */\nexport function generateSecretKey(): Uint8Array {\n\treturn Scalar.random().toBytes();\n}\n\n/** Derive the BLS public key for a given secret key. */\nexport function toPublicKey(sk: Uint8Array): Uint8Array {\n\treturn G1Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();\n}\n\n/** Derive the BLS verification key for a given secret key. */\nexport function toVerificationKey(sk: Uint8Array): Uint8Array {\n\treturn G2Element.generator().multiply(Scalar.fromBytes(sk)).toBytes();\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64, toHex } from '@mysten/bcs';\n\nimport { elgamalDecrypt, toPublicKey, toVerificationKey } from './elgamal.js';\nimport { SealAPIError } from './error.js';\nimport type { Certificate } from './session-key.js';\nimport { PACKAGE_VERSION } from './version.js';\n\n/**\n * Helper function to request all keys from URL with requestSig, txBytes, ephemeral pubkey.\n * Then decrypt the Seal key with ephemeral secret key. Returns a list decryption keys with\n * their full IDs.\n *\n * @param url - The URL of the key server.\n * @param requestSig - The Base64 string of request signature.\n * @param txBytes - The transaction bytes.\n * @param encKey - The ephemeral secret key.\n * @param certificate - The certificate.\n * @returns - A list of full ID and the decrypted key.\n */\nexport async function fetchKeysForAllIds(\n\turl: string,\n\trequestSig: string,\n\ttxBytes: Uint8Array,\n\tencKey: Uint8Array,\n\tcertificate: Certificate,\n\ttimeout: number,\n\tsignal?: AbortSignal,\n): Promise<{ fullId: string; key: Uint8Array }[]> {\n\tconst encKeyPk = toPublicKey(encKey);\n\tconst encVerificationKey = toVerificationKey(encKey);\n\tconst body = {\n\t\tptb: toBase64(txBytes.slice(1)), // removes the byte of the transaction type version\n\t\tenc_key: toBase64(encKeyPk),\n\t\tenc_verification_key: toBase64(encVerificationKey),\n\t\trequest_signature: requestSig, // already b64\n\t\tcertificate,\n\t};\n\n\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\tconst combinedSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;\n\n\tconst requestId = crypto.randomUUID();\n\tconst response = await fetch(url + '/v1/fetch_key', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Request-Id': requestId,\n\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t},\n\t\tbody: JSON.stringify(body),\n\t\tsignal: combinedSignal,\n\t});\n\tawait SealAPIError.assertResponse(response, requestId);\n\n\tconst resp = await response.json();\n\treturn resp.decryption_keys.map((dk: { id: Uint8Array; encrypted_key: [string, string] }) => ({\n\t\tfullId: toHex(new Uint8Array(dk.id)),\n\t\tkey: elgamalDecrypt(encKey, dk.encrypted_key.map(fromBase64) as [Uint8Array, Uint8Array]),\n\t}));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\n\nimport { EncryptedObject } from './bcs.js';\nimport { G1Element, G2Element } from './bls12381.js';\nimport { decrypt } from './decrypt.js';\nimport type { EncryptionInput } from './dem.js';\nimport { AesGcm256, Hmac256Ctr } from './dem.js';\nimport { DemType, encrypt, KemType } from './encrypt.js';\nimport {\n\tInconsistentKeyServersError,\n\tInvalidKeyServerError,\n\tInvalidThresholdError,\n\ttoMajorityError,\n} from './error.js';\nimport { BonehFranklinBLS12381Services, DST } from './ibe.js';\nimport { KeyServerType, retrieveKeyServers, verifyKeyServer } from './key-server.js';\nimport type { KeyServer } from './key-server.js';\nimport { fetchKeysForAllIds } from './keys.js';\nimport type { SessionKey } from './session-key.js';\nimport type { KeyCacheKey } from './types.js';\nimport { createFullId } from './utils.js';\n\n/**\n * Configuration options for initializing a SealClient\n * @property serverObjectIds: Array of object IDs for the key servers to use.\n * @property verifyKeyServers: Whether to verify the key servers' authenticity.\n * \t Should be false if servers are pre-verified (e.g., getAllowlistedKeyServers).\n * \t Defaults to true.\n * @property timeout: Timeout in milliseconds for network requests. Defaults to 10 seconds.\n */\nexport interface SealClientOptions {\n\tsuiClient: SuiClient;\n\tserverObjectIds: string[];\n\tverifyKeyServers?: boolean;\n\ttimeout?: number;\n}\n\nexport class SealClient {\n\t#suiClient: SuiClient;\n\t#serverObjectIds: string[];\n\t#verifyKeyServers: boolean;\n\t#keyServers: Promise<KeyServer[]> | null = null;\n\t// A caching map for: fullId:object_id -> partial key.\n\t#cachedKeys = new Map<KeyCacheKey, G1Element>();\n\t#timeout: number;\n\n\tconstructor(options: SealClientOptions) {\n\t\tthis.#suiClient = options.suiClient;\n\t\tthis.#serverObjectIds = options.serverObjectIds;\n\t\tthis.#verifyKeyServers = options.verifyKeyServers ?? true;\n\t\tthis.#timeout = options.timeout ?? 10_000;\n\t}\n\n\t/**\n\t * Return an encrypted message under the identity.\n\t *\n\t * @param kemType - The type of KEM to use.\n\t * @param demType - The type of DEM to use.\n\t * @param threshold - The threshold for the TSS encryption.\n\t * @param packageId - the packageId namespace.\n\t * @param id - the identity to use.\n\t * @param data - the data to encrypt.\n\t * @param aad - optional additional authenticated data.\n\t * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.\n\t * \tSince the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.\n\t */\n\tasync encrypt({\n\t\tkemType = KemType.BonehFranklinBLS12381DemCCA,\n\t\tdemType = DemType.AesGcm256,\n\t\tthreshold,\n\t\tpackageId,\n\t\tid,\n\t\tdata,\n\t\taad = new Uint8Array(),\n\t}: {\n\t\tkemType?: KemType;\n\t\tdemType?: DemType;\n\t\tthreshold: number;\n\t\tpackageId: string;\n\t\tid: string;\n\t\tdata: Uint8Array;\n\t\taad?: Uint8Array;\n\t}) {\n\t\t// TODO: Verify that packageId is first version of its package (else throw error).\n\t\treturn encrypt({\n\t\t\tkeyServers: await this.getKeyServers(),\n\t\t\tkemType,\n\t\t\tthreshold,\n\t\t\tpackageId,\n\t\t\tid,\n\t\t\tencryptionInput: this.#createEncryptionInput(demType, data, aad),\n\t\t});\n\t}\n\n\t#createEncryptionInput(type: DemType, data: Uint8Array, aad: Uint8Array): EncryptionInput {\n\t\tswitch (type) {\n\t\t\tcase DemType.AesGcm256:\n\t\t\t\treturn new AesGcm256(data, aad);\n\t\t\tcase DemType.Hmac256Ctr:\n\t\t\t\treturn new Hmac256Ctr(data, aad);\n\t\t}\n\t}\n\n\t/**\n\t * Decrypt the given encrypted bytes using cached keys.\n\t * Calls fetchKeys in case one or more of the required keys is not cached yet.\n\t * The function throws an error if the client's key servers are not a subset of\n\t * the encrypted object's key servers (including the same weights) or if the\n\t * threshold cannot be met.\n\t *\n\t * @param data - The encrypted bytes to decrypt.\n\t * @param sessionKey - The session key to use.\n\t * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).\n\t * @returns - The decrypted plaintext corresponding to ciphertext.\n\t */\n\tasync decrypt({\n\t\tdata,\n\t\tsessionKey,\n\t\ttxBytes,\n\t}: {\n\t\tdata: Uint8Array;\n\t\tsessionKey: SessionKey;\n\t\ttxBytes: Uint8Array;\n\t}) {\n\t\tconst encryptedObject = EncryptedObject.parse(data);\n\n\t\tthis.#validateEncryptionServices(\n\t\t\tencryptedObject.services.map((s) => s[0]),\n\t\t\tencryptedObject.threshold,\n\t\t);\n\n\t\tawait this.fetchKeys({\n\t\t\tids: [encryptedObject.id],\n\t\t\ttxBytes,\n\t\t\tsessionKey,\n\t\t\tthreshold: encryptedObject.threshold,\n\t\t});\n\n\t\treturn decrypt({ encryptedObject, keys: this.#cachedKeys });\n\t}\n\n\t#validateEncryptionServices(services: string[], threshold: number) {\n\t\t// Check that the client's key servers are a subset of the encrypted object's key servers.\n\t\tconst serverObjectIdsMap = new Map<string, number>();\n\t\tfor (const objectId of this.#serverObjectIds) {\n\t\t\tserverObjectIdsMap.set(objectId, (serverObjectIdsMap.get(objectId) ?? 0) + 1);\n\t\t}\n\t\tconst servicesMap = new Map<string, number>();\n\t\tfor (const service of services) {\n\t\t\tservicesMap.set(service, (servicesMap.get(service) ?? 0) + 1);\n\t\t}\n\t\tfor (const [objectId, count] of serverObjectIdsMap) {\n\t\t\tif (servicesMap.get(objectId) !== count) {\n\t\t\t\tthrow new InconsistentKeyServersError(\n\t\t\t\t\t`Client's key servers must be a subset of the encrypted object's key servers`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Check that the threshold can be met with the client's key servers.\n\t\tif (threshold > this.#serverObjectIds.length) {\n\t\t\tthrow new InvalidThresholdError(\n\t\t\t\t`Invalid threshold ${threshold} for ${this.#serverObjectIds.length} servers`,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync getKeyServers() {\n\t\tif (!this.#keyServers) {\n\t\t\tthis.#keyServers = this.#loadKeyServers().catch((error) => {\n\t\t\t\tthis.#keyServers = null;\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\n\t\treturn this.#keyServers;\n\t}\n\n\tasync #loadKeyServers(): Promise<KeyServer[]> {\n\t\tconst keyServers = await retrieveKeyServers({\n\t\t\tobjectIds: this.#serverObjectIds,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (keyServers.length === 0) {\n\t\t\tthrow new InvalidKeyServerError('No key servers found');\n\t\t}\n\n\t\tif (this.#verifyKeyServers) {\n\t\t\tawait Promise.all(\n\t\t\t\tkeyServers.map(async (server) => {\n\t\t\t\t\tif (!(await verifyKeyServer(server, this.#timeout))) {\n\t\t\t\t\t\tthrow new InvalidKeyServerError(`Key server ${server.objectId} is not valid`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn keyServers;\n\t}\n\n\t/**\n\t * Fetch keys from the key servers and update the cache.\n\t *\n\t * It is recommended to call this function once for all ids of all encrypted obejcts if\n\t * there are multiple, then call decrypt for each object. This avoids calling fetchKey\n\t * individually for each decrypt.\n\t *\n\t * @param ids - The ids of the encrypted objects.\n\t * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).\n\t * @param sessionKey - The session key to use.\n\t * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.\n\t */\n\tasync fetchKeys({\n\t\tids,\n\t\ttxBytes,\n\t\tsessionKey,\n\t\tthreshold,\n\t}: {\n\t\tids: string[];\n\t\ttxBytes: Uint8Array;\n\t\tsessionKey: SessionKey;\n\t\tthreshold: number;\n\t}) {\n\t\tconst keyServers = await this.getKeyServers();\n\t\tif (threshold > keyServers.length || threshold < 1 || keyServers.length < 1) {\n\t\t\tthrow new InvalidThresholdError(\n\t\t\t\t`Invalid threshold ${threshold} for ${keyServers.length} servers`,\n\t\t\t);\n\t\t}\n\n\t\tlet completedServerCount = 0;\n\t\tconst remainingKeyServers = new Set<KeyServer>();\n\t\tconst fullIds = ids.map((id) => createFullId(DST, sessionKey.getPackageId(), id));\n\n\t\t// Count a server as completed if it has keys for all fullIds.\n\t\t// Duplicated key server ids will be counted towards the threshold.\n\t\tfor (const server of keyServers) {\n\t\t\tlet hasAllKeys = true;\n\t\t\tfor (const fullId of fullIds) {\n\t\t\t\tif (!this.#cachedKeys.has(`${fullId}:${server.objectId}`)) {\n\t\t\t\t\thasAllKeys = false;\n\t\t\t\t\tremainingKeyServers.add(server);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasAllKeys) {\n\t\t\t\tcompletedServerCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Return early if we have enough keys from cache.\n\t\tif (completedServerCount >= threshold) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check server validities.\n\t\tfor (const server of remainingKeyServers) {\n\t\t\tif (server.keyType !== KeyServerType.BonehFranklinBLS12381) {\n\t\t\t\tthrow new InvalidKeyServerError(\n\t\t\t\t\t`Server ${server.objectId} has invalid key type: ${server.keyType}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst cert = await sessionKey.getCertificate();\n\t\tconst signedRequest = await sessionKey.createRequestParams(txBytes);\n\n\t\tconst controller = new AbortController();\n\t\tconst errors: Error[] = [];\n\n\t\tconst keyFetches = [...remainingKeyServers].map(async (server) => {\n\t\t\ttry {\n\t\t\t\tconst allKeys = await fetchKeysForAllIds(\n\t\t\t\t\tserver.url,\n\t\t\t\t\tsignedRequest.requestSignature,\n\t\t\t\t\ttxBytes,\n\t\t\t\t\tsignedRequest.decryptionKey,\n\t\t\t\t\tcert,\n\t\t\t\t\tthis.#timeout,\n\t\t\t\t\tcontroller.signal,\n\t\t\t\t);\n\t\t\t\t// Check validity of the keys and add them to the cache.\n\t\t\t\tlet receivedIds = new Set<string>();\n\t\t\t\tfor (const { fullId, key } of allKeys) {\n\t\t\t\t\tconst keyElement = G1Element.fromBytes(key);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!BonehFranklinBLS12381Services.verifyUserSecretKey(\n\t\t\t\t\t\t\tkeyElement,\n\t\t\t\t\t\t\tfullId,\n\t\t\t\t\t\t\tG2Element.fromBytes(server.pk),\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconsole.warn('Received invalid key from key server ' + server.objectId);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis.#cachedKeys.set(`${fullId}:${server.objectId}`, keyElement);\n\t\t\t\t\treceivedIds.add(fullId);\n\t\t\t\t}\n\n\t\t\t\t// Check if all the receivedIds are consistent with the requested fullIds.\n\t\t\t\t// If so, consider the key server got all keys and mark as completed.\n\t\t\t\tconst expectedIds = new Set(fullIds);\n\t\t\t\tconst hasAllKeys =\n\t\t\t\t\treceivedIds.size === expectedIds.size &&\n\t\t\t\t\t[...receivedIds].every((id) => expectedIds.has(id));\n\n\t\t\t\t// Return early if the completed servers is more than threshold.\n\t\t\t\tif (hasAllKeys) {\n\t\t\t\t\tcompletedServerCount++;\n\t\t\t\t\tif (completedServerCount >= threshold) {\n\t\t\t\t\t\tcontroller.abort();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!controller.signal.aborted) {\n\t\t\t\t\terrors.push(error as Error);\n\t\t\t\t}\n\t\t\t\t// If there are too many errors that the threshold is not attainable, return early with error.\n\t\t\t\tif (remainingKeyServers.size - errors.length < threshold - completedServerCount) {\n\t\t\t\t\tcontroller.abort(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.allSettled(keyFetches);\n\n\t\tif (completedServerCount < threshold) {\n\t\t\tthrow toMajorityError(errors);\n\t\t}\n\t}\n}\n", "/**\r\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\r\n *\r\n * Seems to be rigid (not backdoored)\r\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\r\n *\r\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\r\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\r\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\r\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { randomBytes } from '@noble/hashes/utils';\r\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.js';\r\nimport { createHasher, type HTFMethod, isogenyMap } from './abstract/hash-to-curve.js';\r\nimport { Field, mod, pow2 } from './abstract/modular.js';\r\nimport type { Hex, PrivKey } from './abstract/utils.js';\r\nimport {\r\n  aInRange,\r\n  bytesToNumberBE,\r\n  concatBytes,\r\n  ensureBytes,\r\n  inRange,\r\n  numberToBytesBE,\r\n} from './abstract/utils.js';\r\nimport { mapToCurveSimpleSWU, type ProjPointType as PointType } from './abstract/weierstrass.js';\r\n\r\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\r\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\r\nconst _1n = BigInt(1);\r\nconst _2n = BigInt(2);\r\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\r\n\r\n/**\r\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\r\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\r\n */\r\nfunction sqrtMod(y: bigint): bigint {\r\n  const P = secp256k1P;\r\n  // prettier-ignore\r\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\r\n  // prettier-ignore\r\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\r\n  const b2 = (y * y * y) % P; // x^3, 11\r\n  const b3 = (b2 * b2 * y) % P; // x^7\r\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\r\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\r\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\r\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\r\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\r\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\r\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\r\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\r\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\r\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\r\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\r\n  const root = pow2(t2, _2n, P);\r\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\r\n  return root;\r\n}\r\n\r\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\r\n\r\n/**\r\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\r\n *\r\n * @example\r\n * import { secp256k1 } from '@noble/curves/secp256k1';\r\n *\r\n * const priv = secp256k1.utils.randomPrivateKey();\r\n * const pub = secp256k1.getPublicKey(priv);\r\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\r\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\r\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\r\n */\r\nexport const secp256k1: CurveFnWithCreate = createCurve(\r\n  {\r\n    a: BigInt(0), // equation params: a, b\r\n    b: BigInt(7),\r\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\r\n    n: secp256k1N, // Curve order, total count of valid points in the field\r\n    // Base point (x, y) aka generator point\r\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\r\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\r\n    h: BigInt(1), // Cofactor\r\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\r\n    endo: {\r\n      // Endomorphism, see above\r\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\r\n      splitScalar: (k: bigint) => {\r\n        const n = secp256k1N;\r\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\r\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\r\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\r\n        const b2 = a1;\r\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\r\n\r\n        const c1 = divNearest(b2 * k, n);\r\n        const c2 = divNearest(-b1 * k, n);\r\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\r\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\r\n        const k1neg = k1 > POW_2_128;\r\n        const k2neg = k2 > POW_2_128;\r\n        if (k1neg) k1 = n - k1;\r\n        if (k2neg) k2 = n - k2;\r\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\r\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\r\n        }\r\n        return { k1neg, k1, k2neg, k2 };\r\n      },\r\n    },\r\n  },\r\n  sha256\r\n);\r\n\r\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\r\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\nconst _0n = BigInt(0);\r\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\r\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\r\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\r\n  let tagP = TAGGED_HASH_PREFIXES[tag];\r\n  if (tagP === undefined) {\r\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\r\n    tagP = concatBytes(tagH, tagH);\r\n    TAGGED_HASH_PREFIXES[tag] = tagP;\r\n  }\r\n  return sha256(concatBytes(tagP, ...messages));\r\n}\r\n\r\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\r\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\r\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\r\nconst modP = (x: bigint) => mod(x, secp256k1P);\r\nconst modN = (x: bigint) => mod(x, secp256k1N);\r\nconst Point = secp256k1.ProjectivePoint;\r\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\r\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\r\n\r\n// Calculate point, scalar and bytes\r\nfunction schnorrGetExtPubKey(priv: PrivKey) {\r\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\r\n  let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\r\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\r\n  return { scalar: scalar, bytes: pointToBytes(p) };\r\n}\r\n/**\r\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\r\n * @returns valid point checked for being on-curve\r\n */\r\nfunction lift_x(x: bigint): PointType<bigint> {\r\n  aInRange('x', x, _1n, secp256k1P); // Fail if x ≥ p.\r\n  const xx = modP(x * x);\r\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\r\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\r\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\r\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\r\n  p.assertValidity();\r\n  return p;\r\n}\r\nconst num = bytesToNumberBE;\r\n/**\r\n * Create tagged hash, convert it to bigint, reduce modulo-n.\r\n */\r\nfunction challenge(...args: Uint8Array[]): bigint {\r\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\r\n}\r\n\r\n/**\r\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\r\n */\r\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\r\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\r\n}\r\n\r\n/**\r\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\r\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\r\n */\r\nfunction schnorrSign(\r\n  message: Hex,\r\n  privateKey: PrivKey,\r\n  auxRand: Hex = randomBytes(32)\r\n): Uint8Array {\r\n  const m = ensureBytes('message', message);\r\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\r\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\r\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\r\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\r\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\r\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\r\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\r\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\r\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\r\n  sig.set(rx, 0);\r\n  sig.set(numTo32b(modN(k + e * d)), 32);\r\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\r\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\r\n  return sig;\r\n}\r\n\r\n/**\r\n * Verifies Schnorr signature.\r\n * Will swallow errors & return false except for initial type validation of arguments.\r\n */\r\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\r\n  const sig = ensureBytes('signature', signature, 64);\r\n  const m = ensureBytes('message', message);\r\n  const pub = ensureBytes('publicKey', publicKey, 32);\r\n  try {\r\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\r\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\r\n    if (!inRange(r, _1n, secp256k1P)) return false;\r\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\r\n    if (!inRange(s, _1n, secp256k1N)) return false;\r\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\r\n    const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\r\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\r\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport type SecpSchnorr = {\r\n  getPublicKey: typeof schnorrGetPublicKey;\r\n  sign: typeof schnorrSign;\r\n  verify: typeof schnorrVerify;\r\n  utils: {\r\n    randomPrivateKey: () => Uint8Array;\r\n    lift_x: typeof lift_x;\r\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\r\n    numberToBytesBE: typeof numberToBytesBE;\r\n    bytesToNumberBE: typeof bytesToNumberBE;\r\n    taggedHash: typeof taggedHash;\r\n    mod: typeof mod;\r\n  };\r\n};\r\n/**\r\n * Schnorr signatures over secp256k1.\r\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\n * @example\r\n * import { schnorr } from '@noble/curves/secp256k1';\r\n * const priv = schnorr.utils.randomPrivateKey();\r\n * const pub = schnorr.getPublicKey(priv);\r\n * const msg = new TextEncoder().encode('hello');\r\n * const sig = schnorr.sign(msg, priv);\r\n * const isValid = schnorr.verify(sig, msg, pub);\r\n */\r\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => ({\r\n  getPublicKey: schnorrGetPublicKey,\r\n  sign: schnorrSign,\r\n  verify: schnorrVerify,\r\n  utils: {\r\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\r\n    lift_x,\r\n    pointToBytes,\r\n    numberToBytesBE,\r\n    bytesToNumberBE,\r\n    taggedHash,\r\n    mod,\r\n  },\r\n}))();\r\n\r\nconst isoMap = /* @__PURE__ */ (() =>\r\n  isogenyMap(\r\n    Fpk1,\r\n    [\r\n      // xNum\r\n      [\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\r\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\r\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\r\n      ],\r\n      // xDen\r\n      [\r\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\r\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n      ],\r\n      // yNum\r\n      [\r\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\r\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\r\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\r\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\r\n      ],\r\n      // yDen\r\n      [\r\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\r\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\r\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n      ],\r\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\r\n  ))();\r\nconst mapSWU = /* @__PURE__ */ (() =>\r\n  mapToCurveSimpleSWU(Fpk1, {\r\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\r\n    B: BigInt('1771'),\r\n    Z: Fpk1.create(BigInt('-11')),\r\n  }))();\r\nconst htf = /* @__PURE__ */ (() =>\r\n  createHasher(\r\n    secp256k1.ProjectivePoint,\r\n    (scalars: bigint[]) => {\r\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\r\n      return isoMap(x, y);\r\n    },\r\n    {\r\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\r\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\r\n      p: Fpk1.ORDER,\r\n      m: 1,\r\n      k: 128,\r\n      expand: 'xmd',\r\n      hash: sha256,\r\n    }\r\n  ))();\r\n\r\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\r\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.hashToCurve)();\r\n\r\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\r\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.encodeToCurve)();\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport {\n\tbytesEqual,\n\tparseSerializedKeypairSignature,\n\tPublicKey,\n} from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nconst SECP256K1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256k1 public key\n */\nexport class Secp256k1PublicKey extends PublicKey {\n\tstatic SIZE = SECP256K1_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array;\n\n\t/**\n\t * Create a new Secp256k1PublicKey object\n\t * @param value secp256k1 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Secp256k1 public keys are equal\n\t */\n\toverride equals(publicKey: Secp256k1PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256k1 public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256k1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Secp256k1'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedKeypairSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'Secp256k1') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn secp256k1.verify(\n\t\t\tsecp256k1.Signature.fromCompact(bytes),\n\t\t\tsha256(message),\n\t\t\tthis.toRawBytes(),\n\t\t);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../../cryptography/signature.js';\n\nconst SECP256R1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256r1 public key\n */\nexport class Secp256r1PublicKey extends PublicKey {\n\tstatic SIZE = SECP256R1_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array;\n\n\t/**\n\t * Create a new Secp256r1PublicKey object\n\t * @param value secp256r1 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Secp256r1 public keys are equal\n\t */\n\toverride equals(publicKey: Secp256r1PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256r1 public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256r1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Secp256r1'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'Secp256r1') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn secp256r1.verify(\n\t\t\tsecp256r1.Signature.fromCompact(bytes),\n\t\t\tsha256(message),\n\t\t\tthis.toRawBytes(),\n\t\t);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { SignatureScheme } from '../cryptography/index.js';\nimport { Signer } from '../cryptography/index.js';\nimport type { MultiSigPublicKey } from './publickey.js';\n\nexport class MultiSigSigner extends Signer {\n\t#pubkey: MultiSigPublicKey;\n\t#signers: Signer[];\n\n\tconstructor(pubkey: MultiSigPublicKey, signers: Signer[] = []) {\n\t\tsuper();\n\t\tthis.#pubkey = pubkey;\n\t\tthis.#signers = signers;\n\n\t\tlet uniqueKeys = new Set();\n\t\tlet combinedWeight = 0;\n\n\t\tconst weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({\n\t\t\tweight,\n\t\t\taddress: publicKey.toSuiAddress(),\n\t\t}));\n\n\t\tfor (let signer of signers) {\n\t\t\tconst address = signer.toSuiAddress();\n\t\t\tif (uniqueKeys.has(address)) {\n\t\t\t\tthrow new Error(`Can't create MultiSigSigner with duplicate signers`);\n\t\t\t}\n\t\t\tuniqueKeys.add(address);\n\n\t\t\tconst weight = weights.find((w) => w.address === address)?.weight;\n\n\t\t\tif (!weight) {\n\t\t\t\tthrow new Error(`Signer ${address} is not part of the MultiSig public key`);\n\t\t\t}\n\n\t\t\tcombinedWeight += weight;\n\t\t}\n\n\t\tif (combinedWeight < pubkey.getThreshold()) {\n\t\t\tthrow new Error(`Combined weight of signers is less than threshold`);\n\t\t}\n\t}\n\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'MultiSig';\n\t}\n\n\tgetPublicKey(): MultiSigPublicKey {\n\t\treturn this.#pubkey;\n\t}\n\n\tsign(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\tsignData(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\tasync signTransaction(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signTransaction(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signPersonalMessage(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Signer } from '../cryptography/keypair.js';\nimport { bytesEqual, PublicKey } from '../cryptography/publickey.js';\nimport {\n\tSIGNATURE_FLAG_TO_SCHEME,\n\tSIGNATURE_SCHEME_TO_FLAG,\n} from '../cryptography/signature-scheme.js';\nimport type { SignatureFlag, SignatureScheme } from '../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../cryptography/signature.js';\nimport type { SuiGraphQLClient } from '../graphql/client.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n// eslint-disable-next-line import/no-cycle\nimport { publicKeyFromRawBytes } from '../verify/index.js';\nimport { toZkLoginPublicIdentifier } from '../zklogin/publickey.js';\nimport { MultiSigSigner } from './signer.js';\n\ntype CompressedSignature =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] }\n\t| { ZkLogin: number[] };\n\ntype PublicKeyEnum =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] }\n\t| { ZkLogin: number[] };\n\ntype PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\ntype MultiSigPublicKeyStruct = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSigStruct = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKeyStruct;\n};\n\ntype ParsedPartialMultiSigSignature = {\n\tsignatureScheme: SignatureScheme;\n\tsignature: Uint8Array;\n\tpublicKey: PublicKey;\n\tweight: number;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\nexport const MIN_SIGNER_IN_MULTISIG = 1;\n/**\n * A MultiSig public key\n */\nexport class MultiSigPublicKey extends PublicKey {\n\tprivate rawBytes: Uint8Array;\n\tprivate multisigPublicKey: MultiSigPublicKeyStruct;\n\tprivate publicKeys: {\n\t\tweight: number;\n\t\tpublicKey: PublicKey;\n\t}[];\n\t/**\n\t * Create a new MultiSigPublicKey object\n\t */\n\tconstructor(\n\t\t/**\n\t\t *  MultiSig public key as buffer or base-64 encoded string\n\t\t */\n\t\tvalue: string | Uint8Array | MultiSigPublicKeyStruct,\n\t\toptions: { client?: SuiGraphQLClient } = {},\n\t) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.rawBytes = fromBase64(value);\n\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.rawBytes = value;\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else {\n\t\t\tthis.multisigPublicKey = value;\n\t\t\tthis.rawBytes = bcs.MultiSigPublicKey.serialize(value).toBytes();\n\t\t}\n\t\tif (this.multisigPublicKey.threshold < 1) {\n\t\t\tthrow new Error('Invalid threshold');\n\t\t}\n\n\t\tconst seenPublicKeys = new Set<string>();\n\n\t\tthis.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {\n\t\t\tconst [scheme, bytes] = Object.entries(pubKey).filter(([name]) => name !== '$kind')[0] as [\n\t\t\t\tSignatureScheme,\n\t\t\t\tnumber[],\n\t\t\t];\n\t\t\tconst publicKeyStr = Uint8Array.from(bytes).toString();\n\n\t\t\tif (seenPublicKeys.has(publicKeyStr)) {\n\t\t\t\tthrow new Error(`Multisig does not support duplicate public keys`);\n\t\t\t}\n\t\t\tseenPublicKeys.add(publicKeyStr);\n\n\t\t\tif (weight < 1) {\n\t\t\t\tthrow new Error(`Invalid weight`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpublicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),\n\t\t\t\tweight,\n\t\t\t};\n\t\t});\n\n\t\tconst totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);\n\n\t\tif (this.multisigPublicKey.threshold > totalWeight) {\n\t\t\tthrow new Error(`Unreachable threshold`);\n\t\t}\n\n\t\tif (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tif (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);\n\t\t}\n\t}\n\t/**\n\t * \tA static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.\n\t */\n\n\tstatic fromPublicKeys({\n\t\tthreshold,\n\t\tpublicKeys,\n\t}: {\n\t\tthreshold: number;\n\t\tpublicKeys: { publicKey: PublicKey; weight: number }[];\n\t}) {\n\t\treturn new MultiSigPublicKey({\n\t\t\tpk_map: publicKeys.map(({ publicKey, weight }) => {\n\t\t\t\tconst scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as SignatureFlag];\n\n\t\t\t\treturn {\n\t\t\t\t\tpubKey: { [scheme]: Array.from(publicKey.toRawBytes()) } as PublicKeyEnum,\n\t\t\t\t\tweight,\n\t\t\t\t};\n\t\t\t}),\n\t\t\tthreshold,\n\t\t});\n\t}\n\n\t/**\n\t * Checks if two MultiSig public keys are equal\n\t */\n\toverride equals(publicKey: MultiSigPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the MultiSig public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.rawBytes;\n\t}\n\n\tgetPublicKeys() {\n\t\treturn this.publicKeys;\n\t}\n\n\tgetThreshold() {\n\t\treturn this.multisigPublicKey.threshold;\n\t}\n\n\tgetSigner(...signers: [signer: Signer]) {\n\t\treturn new MultiSigSigner(this, signers);\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\toverride toSuiAddress(): string {\n\t\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\t\tconst maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\t\tconst tmp = new Uint8Array(maxLength);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\t\ttmp.set(bcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);\n\t\t// The initial value 3 ensures that following data will be after the flag byte and threshold bytes\n\t\tlet i = 3;\n\t\tfor (const { publicKey, weight } of this.publicKeys) {\n\t\t\tconst bytes = publicKey.toSuiBytes();\n\t\t\ttmp.set(bytes, i);\n\t\t\ti += bytes.length;\n\t\t\ttmp.set([weight], i++);\n\t\t}\n\t\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['MultiSig'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, multisigSignature: string): Promise<boolean> {\n\t\t// Multisig verification only supports serialized signature\n\t\tconst parsed = parseSerializedSignature(multisigSignature);\n\n\t\tif (parsed.signatureScheme !== 'MultiSig') {\n\t\t\tthrow new Error('Invalid signature scheme');\n\t\t}\n\n\t\tconst { multisig } = parsed;\n\n\t\tlet signatureWeight = 0;\n\n\t\tif (\n\t\t\t!bytesEqual(\n\t\t\t\tbcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),\n\t\t\t\tbcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes(),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {\n\t\t\tif (!(await publicKey.verify(message, signature))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsignatureWeight += weight;\n\t\t}\n\n\t\treturn signatureWeight >= this.multisigPublicKey.threshold;\n\t}\n\n\t/**\n\t * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once\n\t * and that all the public keys involved are known and valid, and then serializes multisig into the standard format\n\t */\n\tcombinePartialSignatures(signatures: string[]): string {\n\t\tif (signatures.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tlet bitmap = 0;\n\t\tconst compressedSignatures: CompressedSignature[] = new Array(signatures.length);\n\n\t\tfor (let i = 0; i < signatures.length; i++) {\n\t\t\tlet parsed = parseSerializedSignature(signatures[i]);\n\t\t\tif (parsed.signatureScheme === 'MultiSig') {\n\t\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t\t}\n\n\t\t\tlet publicKey;\n\t\t\tif (parsed.signatureScheme === 'ZkLogin') {\n\t\t\t\tpublicKey = toZkLoginPublicIdentifier(\n\t\t\t\t\tparsed.zkLogin?.addressSeed,\n\t\t\t\t\tparsed.zkLogin?.iss,\n\t\t\t\t).toRawBytes();\n\t\t\t} else {\n\t\t\t\tpublicKey = parsed.publicKey;\n\t\t\t}\n\n\t\t\tcompressedSignatures[i] = {\n\t\t\t\t[parsed.signatureScheme]: Array.from(parsed.signature.map((x: number) => Number(x))),\n\t\t\t} as CompressedSignature;\n\n\t\t\tlet publicKeyIndex;\n\t\t\tfor (let j = 0; j < this.publicKeys.length; j++) {\n\t\t\t\tif (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n\t\t\t\t\tif (bitmap & (1 << j)) {\n\t\t\t\t\t\tthrow new Error('Received multiple signatures from the same public key');\n\t\t\t\t\t}\n\n\t\t\t\t\tpublicKeyIndex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (publicKeyIndex === undefined) {\n\t\t\t\tthrow new Error('Received signature from unknown public key');\n\t\t\t}\n\n\t\t\tbitmap |= 1 << publicKeyIndex;\n\t\t}\n\n\t\tlet multisig: MultiSigStruct = {\n\t\t\tsigs: compressedSignatures,\n\t\t\tbitmap,\n\t\t\tmultisig_pk: this.multisigPublicKey,\n\t\t};\n\t\tconst bytes = bcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();\n\t\tlet tmp = new Uint8Array(bytes.length + 1);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\t\ttmp.set(bytes, 1);\n\t\treturn toBase64(tmp);\n\t}\n}\n\n/**\n * Parse multisig structure into an array of individual signatures: signature scheme, the actual individual signature, public key and its weight.\n */\nexport function parsePartialSignatures(\n\tmultisig: MultiSigStruct,\n\toptions: { client?: SuiGraphQLClient } = {},\n): ParsedPartialMultiSigSignature[] {\n\tlet res: ParsedPartialMultiSigSignature[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tconst [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(\n\t\t\t([name]) => name !== '$kind',\n\t\t)[0] as [SignatureScheme, number[]];\n\t\tconst pkIndex = asIndices(multisig.bitmap).at(i)!;\n\t\tconst pair = multisig.multisig_pk.pk_map[pkIndex];\n\t\tconst pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n\n\t\tif (signatureScheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);\n\n\t\tres[i] = {\n\t\t\tsignatureScheme,\n\t\t\tsignature: Uint8Array.from(signature),\n\t\t\tpublicKey: publicKey,\n\t\t\tweight: pair.weight,\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction asIndices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\n\nimport type { PublicKey, SignatureFlag, SignatureScheme } from '../cryptography/index.js';\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from '../cryptography/index.js';\nimport type { SuiGraphQLClient } from '../graphql/client.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { PasskeyPublicKey } from '../keypairs/passkey/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\n// eslint-disable-next-line import/no-cycle\nimport { MultiSigPublicKey } from '../multisig/publickey.js';\nimport { ZkLoginPublicIdentifier } from '../zklogin/publickey.js';\n\nexport async function verifySignature(\n\tbytes: Uint8Array,\n\tsignature: string,\n\toptions?: {\n\t\taddress?: string;\n\t},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature);\n\n\tif (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n\t\tthrow new Error(`Signature is not valid for the provided data`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyPersonalMessageSignature(\n\tmessage: Uint8Array,\n\tsignature: string,\n\toptions: { client?: SuiGraphQLClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyPersonalMessage(\n\t\t\tmessage,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided message`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyTransactionSignature(\n\ttransaction: Uint8Array,\n\tsignature: string,\n\toptions: { client?: SuiGraphQLClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyTransaction(\n\t\t\ttransaction,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided Transaction`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nfunction parseSignature(signature: string, options: { client?: SuiGraphQLClient } = {}) {\n\tconst parsedSignature = parseSerializedSignature(signature);\n\n\tif (parsedSignature.signatureScheme === 'MultiSig') {\n\t\treturn {\n\t\t\t...parsedSignature,\n\t\t\tpublicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk),\n\t\t};\n\t}\n\n\tconst publicKey = publicKeyFromRawBytes(\n\t\tparsedSignature.signatureScheme,\n\t\tparsedSignature.publicKey,\n\t\toptions,\n\t);\n\treturn {\n\t\t...parsedSignature,\n\t\tpublicKey,\n\t};\n}\n\nexport function publicKeyFromRawBytes(\n\tsignatureScheme: SignatureScheme,\n\tbytes: Uint8Array,\n\toptions: { client?: SuiGraphQLClient } = {},\n): PublicKey {\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\t\treturn new Ed25519PublicKey(bytes);\n\t\tcase 'Secp256k1':\n\t\t\treturn new Secp256k1PublicKey(bytes);\n\t\tcase 'Secp256r1':\n\t\t\treturn new Secp256r1PublicKey(bytes);\n\t\tcase 'MultiSig':\n\t\t\treturn new MultiSigPublicKey(bytes);\n\t\tcase 'ZkLogin':\n\t\t\treturn new ZkLoginPublicIdentifier(bytes, options);\n\t\tcase 'Passkey':\n\t\t\treturn new PasskeyPublicKey(bytes);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported signature scheme ${signatureScheme}`);\n\t}\n}\n\nexport function publicKeyFromSuiBytes(\n\tpublicKey: string | Uint8Array,\n\toptions: { client?: SuiGraphQLClient } = {},\n) {\n\tconst bytes = typeof publicKey === 'string' ? fromBase64(publicKey) : publicKey;\n\n\tconst signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0] as SignatureFlag];\n\n\treturn publicKeyFromRawBytes(signatureScheme, bytes.slice(1), options);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { SuiGraphQLClient } from '@mysten/sui/graphql';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport { isValidSuiAddress, isValidSuiObjectId } from '@mysten/sui/utils';\nimport { verifyPersonalMessageSignature } from '@mysten/sui/verify';\n\nimport { generateSecretKey, toPublicKey, toVerificationKey } from './elgamal.js';\nimport {\n\tExpiredSessionKeyError,\n\tInvalidPersonalMessageSignatureError,\n\tUserError,\n} from './error.js';\n\nexport const RequestFormat = bcs.struct('RequestFormat', {\n\tptb: bcs.vector(bcs.U8),\n\tencKey: bcs.vector(bcs.U8),\n\tencVerificationKey: bcs.vector(bcs.U8),\n});\n\nexport type Certificate = {\n\tuser: string;\n\tsession_vk: string;\n\tcreation_time: number;\n\tttl_min: number;\n\tsignature: string;\n};\n\nexport class SessionKey {\n\t#address: string;\n\t#packageId: string;\n\t#creationTimeMs: number;\n\t#ttlMin: number;\n\t#sessionKey: Ed25519Keypair;\n\t#personalMessageSignature?: string;\n\t#signer?: Signer;\n\n\tconstructor({\n\t\taddress,\n\t\tpackageId,\n\t\tttlMin,\n\t\tsigner,\n\t}: {\n\t\taddress: string;\n\t\tpackageId: string;\n\t\tttlMin: number;\n\t\tsigner?: Signer;\n\t}) {\n\t\tif (!isValidSuiObjectId(packageId) || !isValidSuiAddress(address)) {\n\t\t\tthrow new UserError(`Invalid package ID ${packageId} or address ${address}`);\n\t\t}\n\t\tif (ttlMin > 10 || ttlMin < 1) {\n\t\t\tthrow new UserError(`Invalid TTL ${ttlMin}, must be between 1 and 10`);\n\t\t}\n\n\t\tthis.#address = address;\n\t\tthis.#packageId = packageId;\n\t\tthis.#creationTimeMs = Date.now();\n\t\tthis.#ttlMin = ttlMin;\n\t\tthis.#sessionKey = Ed25519Keypair.generate();\n\t\tthis.#signer = signer;\n\t}\n\n\tisExpired(): boolean {\n\t\t// Allow 10 seconds for clock skew\n\t\treturn this.#creationTimeMs + this.#ttlMin * 60 * 1000 - 10_000 < Date.now();\n\t}\n\n\tgetAddress(): string {\n\t\treturn this.#address;\n\t}\n\n\tgetPackageId(): string {\n\t\treturn this.#packageId;\n\t}\n\n\tgetPersonalMessage(): Uint8Array {\n\t\tconst creationTimeUtc =\n\t\t\tnew Date(this.#creationTimeMs).toISOString().slice(0, 19).replace('T', ' ') + ' UTC';\n\t\tconst message = `Accessing keys of package ${this.#packageId} for ${this.#ttlMin} mins from ${creationTimeUtc}, session key ${toBase64(this.#sessionKey.getPublicKey().toRawBytes())}`;\n\t\treturn new TextEncoder().encode(message);\n\t}\n\n\tasync setPersonalMessageSignature(personalMessageSignature: string) {\n\t\ttry {\n\t\t\t// TODO: Fix this to work with any network\n\t\t\tawait verifyPersonalMessageSignature(this.getPersonalMessage(), personalMessageSignature, {\n\t\t\t\taddress: this.#address,\n\t\t\t\tclient: new SuiGraphQLClient({\n\t\t\t\t\turl: 'https://sui-testnet.mystenlabs.com/graphql',\n\t\t\t\t}),\n\t\t\t});\n\t\t\tthis.#personalMessageSignature = personalMessageSignature;\n\t\t} catch (e) {\n\t\t\tthrow new InvalidPersonalMessageSignatureError('Not valid');\n\t\t}\n\t}\n\n\tasync getCertificate(): Promise<Certificate> {\n\t\tif (!this.#personalMessageSignature) {\n\t\t\tif (this.#signer) {\n\t\t\t\tconst { signature } = await this.#signer.signPersonalMessage(this.getPersonalMessage());\n\t\t\t\tthis.#personalMessageSignature = signature;\n\t\t\t} else {\n\t\t\t\tthrow new InvalidPersonalMessageSignatureError('Personal message signature is not set');\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tuser: this.#address,\n\t\t\tsession_vk: toBase64(this.#sessionKey.getPublicKey().toRawBytes()),\n\t\t\tcreation_time: this.#creationTimeMs,\n\t\t\tttl_min: this.#ttlMin,\n\t\t\tsignature: this.#personalMessageSignature,\n\t\t};\n\t}\n\n\tasync createRequestParams(\n\t\ttxBytes: Uint8Array,\n\t): Promise<{ decryptionKey: Uint8Array; requestSignature: string }> {\n\t\tif (this.isExpired()) {\n\t\t\tthrow new ExpiredSessionKeyError();\n\t\t}\n\t\tconst egSk = generateSecretKey();\n\t\tconst msgToSign = RequestFormat.serialize({\n\t\t\tptb: txBytes.slice(1),\n\t\t\tencKey: toPublicKey(egSk),\n\t\t\tencVerificationKey: toVerificationKey(egSk),\n\t\t}).toBytes();\n\t\treturn {\n\t\t\tdecryptionKey: egSk,\n\t\t\trequestSignature: toBase64(await this.#sessionKey.sign(msgToSign)),\n\t\t};\n\t}\n}\n"],
  "mappings": "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EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;CAC3F;AAGD,IAAM,YAAkC,IAAI,WAAW;EACrD;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAAM;EAC1F;EAAM;EAAM;EAAM;EAA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",
  "names": ["Fp", "Fr", "Fp2", "Fp6", "Fp12", "msg", "_0n", "_1n", "_2n", "_3n", "Fp", "num", "Fp2", "G2psi", "G2psi2", "FpLegendre", "Fp6", "Fp4Square", "Fp12", "_0n", "_1n", "_2n", "_3n", "num", "x", "bytesToHex", "_SealAPIError", "num", "_0n", "_1n", "_2n", "KeyPurpose", "KeyServerType", "num", "split", "toBytes", "combine", "split", "KemType", "DemType", "decrypt", "__privateAdd", "__privateMethod", "_1n", "_2n", "_3n", "_0n", "__privateAdd", "__privateSet", "__privateGet", "__privateAdd", "__privateSet", "__privateGet"]
}
